use anyhow::Result;
use crossterm::{
    event::{self, DisableMouseCapture, EnableMouseCapture, Event, KeyCode, KeyEventKind},
    execute,
    terminal::{disable_raw_mode, enable_raw_mode, EnterAlternateScreen, LeaveAlternateScreen},
};
use ratatui::{
    backend::CrosstermBackend,
    layout::{Alignment, Constraint, Direction, Layout, Rect},
    style::{Color, Modifier, Style},
    text::{Line, Span},
    widgets::{
        Block, Borders, Gauge, List, ListItem, Paragraph, Wrap, Table, Row, Cell,
    },
    Frame, Terminal,
};
use std::io;
use tokio::time::Duration;
use shared_game_logic::{
    combat::{generate_army_from_cashu_c_value, process_combat},
    game_state::Unit,
};
use integration_tests::core::gaming_wallet::GamingWallet;
use nostr::Keys;
use sha2::Digest;

/// Tutorial application state
pub struct TutorialApp {
    current_phase: usize,
    current_step: usize,
    phases: Vec<TutorialPhase>,
    match_state: MatchState,
    should_quit: bool,
    explanation_scroll: u16,
    explanation_height: u16,
    // Real gaming wallets connected to local services
    alice_wallet: Option<GamingWallet>,
    bob_wallet: Option<GamingWallet>,
    alice_keys: Option<Keys>,
    bob_keys: Option<Keys>,
    show_about: bool,
}

/// Individual tutorial phase
#[derive(Clone)]
pub struct TutorialPhase {
    title: String,
    actor: Actor,
    steps: Vec<TutorialStep>,
}

/// Individual step within a phase
#[derive(Clone)]
pub struct TutorialStep {
    description: String,
    explanation: String,
    action: String,
    technical_notes: Vec<String>,
}

/// Current match state for HUD display
#[derive(Clone)]
pub struct MatchState {
    challenge_id: String,
    total_stake: u32,
    combat_round: u32,
    alice_units: u32,
    bob_units: u32,
    current_actor: Actor,
    // Real combat simulation data
    alice_c_value: Option<[u8; 32]>,
    bob_c_value: Option<[u8; 32]>,
    alice_army: Option<[Unit; 4]>,
    bob_army: Option<[Unit; 4]>,
    combat_results: Vec<CombatRoundResult>,
    animation_frame: u32,
    show_combat_details: bool,
}

/// Combat round result for animation
#[derive(Clone, Debug)]
pub struct CombatRoundResult {
    round: u32,
    alice_unit: Unit,
    bob_unit: Unit,
    alice_damage_dealt: u8,
    bob_damage_dealt: u8,
    winner: Option<String>,
    alice_health_before: u8,
    bob_health_before: u8,
}

/// Actor in the tutorial flow
#[derive(Clone, PartialEq)]
pub enum Actor {
    Alice,
    Bob,
    GameEngine,
    NostrRelay,
    CashuMint,
}

impl Actor {
    fn icon(&self) -> &str {
        match self {
            Actor::Alice => "üë§",
            Actor::Bob => "üë§",
            Actor::GameEngine => "üéÆ",
            Actor::NostrRelay => "üì°",
            Actor::CashuMint => "üè¶",
        }
    }

    fn name(&self) -> &str {
        match self {
            Actor::Alice => "Alice",
            Actor::Bob => "Bob", 
            Actor::GameEngine => "Game Engine",
            Actor::NostrRelay => "Nostr Relay",
            Actor::CashuMint => "Cashu Mint",
        }
    }

    fn color(&self) -> Color {
        match self {
            Actor::Alice | Actor::Bob => Color::Rgb(139, 69, 255), // Purple for players
            Actor::NostrRelay => Color::Blue,                       // Blue for comms
            Actor::GameEngine | Actor::CashuMint => Color::Rgb(255, 153, 0), // Orange for authority
        }
    }
}

impl Default for MatchState {
    fn default() -> Self {
        Self {
            challenge_id: "abc123...".to_string(),
            total_stake: 200,
            combat_round: 1,
            alice_units: 4,
            bob_units: 4,
            current_actor: Actor::Alice,
            alice_c_value: None,
            bob_c_value: None,
            alice_army: None,
            bob_army: None,
            combat_results: Vec::new(),
            animation_frame: 0,
            show_combat_details: false,
        }
    }
}

impl TutorialApp {
    pub fn new() -> Self {
        let phases = vec![
            TutorialPhase {
                title: "üöÄ PHASE 0: Acquire Mana".to_string(),
                actor: Actor::Alice,
                steps: vec![
                    TutorialStep {
                        description: "Alice requests mana tokens from Game Engine's CDK mint".to_string(),
                        explanation: "In Manastr's revolutionary architecture, players acquire mana tokens from the Game Engine's Cashu mint. These tokens contain cryptographic randomness (C values) that players cannot manipulate, ensuring fair army generation.".to_string(),
                        action: "üè¶ Requesting mana tokens with C values...".to_string(),
                        technical_notes: vec![
                            "C values are generated by mint's blinding process".to_string(),
                            "Neither mint nor player can bias this randomness".to_string(),
                            "Deterministic testing uses controlled mint keys".to_string(),
                        ],
                    },
                    TutorialStep {
                        description: "Alice unblinds mana to resolve C value paired with her x value".to_string(),
                        explanation: "The unblinding process reveals the C value - a 32-byte cryptographic proof that will be used to generate Alice's army. This value is authoritative randomness that neither the mint nor Alice could have predetermined.".to_string(),
                        action: "üîì Unblinding mana token to extract C value...".to_string(),
                        technical_notes: vec![
                            "C = mint_signature * mint_pubkey (simplified)".to_string(),
                            "x is Alice's chosen blind factor".to_string(),
                            "Unblinding: proof = C * x^-1".to_string(),
                        ],
                    },
                ],
            },
            TutorialPhase {
                title: "üöÄ PHASE 1: Pick an Army".to_string(),
                actor: Actor::Alice,
                steps: vec![
                    TutorialStep {
                        description: "Alice generates her army from the Cashu C values".to_string(),
                        explanation: "The 32 bytes of the C value are decoded into army units using shared game logic. This is like drawing cards from a cryptographically shuffled deck - Alice now knows her units but no one else does. Different keysets could enable complex meta-protocols like MTG-style gameplay.".to_string(),
                        action: "‚öîÔ∏è Generating army from C value randomness...".to_string(),
                        technical_notes: vec![
                            "32 bytes ‚Üí 4 unit seeds (8 bytes each)".to_string(),
                            "Unit stats: HP, Attack, Defense, Speed".to_string(),
                            "Theming abstracted: Knights? Ninjas? Space Marines?".to_string(),
                        ],
                    },
                    TutorialStep {
                        description: "Alice creates SHA256 commitment of her army composition".to_string(),
                        explanation: "Alice commits to her army using a cryptographic hash. This commitment prevents her from changing her army later while keeping it secret from Bob. This is the foundation of the anti-cheat system - mathematical certainty instead of trust.".to_string(),
                        action: "üîê Creating SHA256 commitment of army...".to_string(),
                        technical_notes: vec![
                            "commit = SHA256(army_units + nonce)".to_string(),
                            "Prevents army manipulation after seeing opponent".to_string(),
                            "Commitment/reveal scheme ensures fair play".to_string(),
                        ],
                    },
                    TutorialStep {
                        description: "Alice publishes KIND 31000 Match Challenge to Nostr".to_string(),
                        explanation: "Alice broadcasts her challenge to the decentralized Nostr network. This event contains her army commitment, stake amount, and challenge terms. The beauty of Nostr is that this can be created offline and published later - perfect for asynchronous gaming.".to_string(),
                        action: "üì° Publishing KIND 31000 Match Challenge event...".to_string(),
                        technical_notes: vec![
                            "Event includes: army_commitment, stake, terms".to_string(),
                            "Cryptographically signed by Alice's key".to_string(),
                            "Can be created offline, published later".to_string(),
                        ],
                    },
                ],
            },
            TutorialPhase {
                title: "üåÄ Temporal Suspension".to_string(),
                actor: Actor::GameEngine,
                steps: vec![
                    TutorialStep {
                        description: "Nostr Relay has received and stored Alice's challenge event".to_string(),
                        explanation: "The beauty of this architecture: Alice's challenge is now permanently stored on the Nostr relay, available for any Game Engine to process. Multiple Game Engines could be running simultaneously, all processing the same events. The services run concurrently, not sequentially.".to_string(),
                        action: "üì° Challenge event stored in Nostr relay...".to_string(),
                        technical_notes: vec![
                            "Event permanently stored in Nostr relay".to_string(),
                            "Multiple Game Engines can process same events".to_string(),
                            "Services run concurrently, asynchronously".to_string(),
                        ],
                    },
                    TutorialStep {
                        description: "Game Engine validates challenge format and updates state to CHALLENGED".to_string(),
                        explanation: "The Game Engine acts as a pure validator, verifying the challenge format and signature. It updates its internal state machine but cannot manipulate the game outcome - it only validates what players have committed to cryptographically.".to_string(),
                        action: "‚úÖ Validating challenge and updating state machine...".to_string(),
                        technical_notes: vec![
                            "Validates: signature, format, stake amount".to_string(),
                            "State transition: NONE ‚Üí CHALLENGED".to_string(),
                            "Engine cannot manipulate player commitments".to_string(),
                        ],
                    },
                ],
            },
            TutorialPhase {
                title: "‚öîÔ∏è PHASE 2: Pick a Fight".to_string(),
                actor: Actor::Bob,
                steps: vec![
                    TutorialStep {
                        description: "Bob requests mana tokens and unblinds to get his C values".to_string(),
                        explanation: "Bob follows the same process as Alice - acquiring mana tokens from the Game Engine's mint and unblinding them to reveal his unique C values. Each player gets their own cryptographically random army composition.".to_string(),
                        action: "üè¶ Bob acquiring mana and extracting C values...".to_string(),
                        technical_notes: vec![
                            "Same mint process as Alice".to_string(),
                            "Independent C values for Bob".to_string(),
                            "Deterministic for testing, random in production".to_string(),
                        ],
                    },
                    TutorialStep {
                        description: "Bob generates his army and creates commitment".to_string(),
                        explanation: "Bob's army is generated from his unique C values using the same shared game logic as Alice. He then creates his own SHA256 commitment. Both players now have committed to their armies without revealing them.".to_string(),
                        action: "‚öîÔ∏è Bob generating army and creating commitment...".to_string(),
                        technical_notes: vec![
                            "Uses same army generation algorithm".to_string(),
                            "Independent commitment: SHA256(bob_army + nonce)".to_string(),
                            "Both armies now committed but secret".to_string(),
                        ],
                    },
                    TutorialStep {
                        description: "Bob publishes KIND 31001 Match Acceptance to Nostr".to_string(),
                        explanation: "Bob accepts Alice's challenge by publishing his own Nostr event. This contains his army commitment and confirms his stake. The match is now officially accepted and both players have committed armies.".to_string(),
                        action: "üì° Publishing KIND 31001 Match Acceptance...".to_string(),
                        technical_notes: vec![
                            "References Alice's challenge event ID".to_string(),
                            "Contains Bob's army commitment".to_string(),
                            "Confirms stake matching Alice's terms".to_string(),
                        ],
                    },
                ],
            },
            TutorialPhase {
                title: "üåÄ Temporal Suspension Complete".to_string(),
                actor: Actor::GameEngine,
                steps: vec![
                    TutorialStep {
                        description: "Nostr Relay has both challenge and acceptance events available".to_string(),
                        explanation: "Both Alice's challenge and Bob's acceptance are now stored in the Nostr relay. The Game Engine can process these events when ready - there's no rush. The cryptographic commitments ensure the integrity of the match state regardless of processing timing.".to_string(),
                        action: "üì° Both events available for Game Engine processing...".to_string(),
                        technical_notes: vec![
                            "Challenge and acceptance events both stored".to_string(),
                            "Game Engine processes at its own pace".to_string(),
                            "Cryptographic integrity maintained throughout".to_string(),
                        ],
                    },
                    TutorialStep {
                        description: "Game Engine processes both events and updates state to ACCEPTED".to_string(),
                        explanation: "The Game Engine validates both the challenge and acceptance events, verifies commitment formats, and updates the match state. Both players have now committed to their armies cryptographically - the match is officially underway.".to_string(),
                        action: "‚úÖ Processing both events and updating match state...".to_string(),
                        technical_notes: vec![
                            "Validates both Alice's and Bob's signatures".to_string(),
                            "State transition: NONE ‚Üí CHALLENGED ‚Üí ACCEPTED".to_string(),
                            "Both army commitments now locked in".to_string(),
                        ],
                    },
                ],
            },
            TutorialPhase {
                title: "üîì PHASE 3: Token Revelation".to_string(),
                actor: Actor::Alice,
                steps: vec![
                    TutorialStep {
                        description: "Alice reveals her actual Cashu tokens via KIND 31002".to_string(),
                        explanation: "Now Alice must reveal her actual Cashu tokens that were used to generate her army. This allows the Game Engine to verify that her army commitment was generated honestly from real C values, not fabricated.".to_string(),
                        action: "üé´ Publishing KIND 31002 Token Reveal...".to_string(),
                        technical_notes: vec![
                            "Reveals: token proofs, C values, x values".to_string(),
                            "Allows army verification without revealing units".to_string(),
                            "Prevents fake army commitments".to_string(),
                        ],
                    },
                    TutorialStep {
                        description: "Bob reveals his actual Cashu tokens via KIND 31002".to_string(),
                        explanation: "Bob follows the same process, revealing his Cashu tokens. Both players have now provided the cryptographic proofs needed for the Game Engine to verify their armies were generated fairly.".to_string(),
                        action: "üé´ Bob publishing KIND 31002 Token Reveal...".to_string(),
                        technical_notes: vec![
                            "Bob's token revelation follows same format".to_string(),
                            "Both players now have verifiable armies".to_string(),
                            "Game Engine can re-generate armies to check".to_string(),
                        ],
                    },
                    TutorialStep {
                        description: "Game Engine verifies tokens and re-generates armies".to_string(),
                        explanation: "The Game Engine queries the Cashu mint to verify both players' tokens are valid and unspent, then re-generates their armies from the revealed C values. It verifies these match the original commitments - catching any cheating attempts.".to_string(),
                        action: "üîç Verifying tokens and army commitments...".to_string(),
                        technical_notes: vec![
                            "Queries mint: are tokens valid and unspent?".to_string(),
                            "Re-generates armies from C values".to_string(),
                            "Verifies: generated_army_hash == commitment".to_string(),
                        ],
                    },
                    TutorialStep {
                        description: "Match state updated to IN_COMBAT - battle begins!".to_string(),
                        explanation: "With both armies verified as legitimate, the Game Engine updates the match state to IN_COMBAT. The cryptographic foundations are complete - now the tactical battle can begin with mathematical certainty of fairness.".to_string(),
                        action: "‚öîÔ∏è Transitioning to combat phase...".to_string(),
                        technical_notes: vec![
                            "State transition: ACCEPTED ‚Üí IN_COMBAT".to_string(),
                            "Both armies verified and ready".to_string(),
                            "Combat can proceed with anti-cheat guarantees".to_string(),
                        ],
                    },
                ],
            },
            TutorialPhase {
                title: "‚öîÔ∏è PHASE 4-6: Combat Simulation (3 Rounds)".to_string(),
                actor: Actor::Alice,
                steps: vec![
                    TutorialStep {
                        description: "Alice (challenger) commits to her moves for Round 1".to_string(),
                        explanation: "Combat uses the same commitment/reveal pattern. Alice chooses tactical moves for each of her units and commits to them with SHA256. This prevents her from changing moves after seeing Bob's commitment - ensuring fair tactical play.".to_string(),
                        action: "üé≤ Creating SHA256 commitment of combat moves...".to_string(),
                        technical_notes: vec![
                            "Challenger (Alice) always moves first".to_string(),
                            "move_commit = SHA256(unit_moves + nonce)".to_string(),
                            "Prevents move manipulation after seeing opponent".to_string(),
                        ],
                    },
                    TutorialStep {
                        description: "Bob sees Alice's commitment and commits to his counter-moves".to_string(),
                        explanation: "Bob receives Alice's move commitment and must commit to his own moves. He can see that Alice has committed to something, but not what those moves are. This creates a simultaneous-play effect even in an asynchronous system.".to_string(),
                        action: "üéØ Bob committing to counter-moves...".to_string(),
                        technical_notes: vec![
                            "Bob's commitment may reference Alice's commitment".to_string(),
                            "Creates simultaneous play in async environment".to_string(),
                            "Both players locked into their tactical decisions".to_string(),
                        ],
                    },
                    TutorialStep {
                        description: "Both players reveal their moves via KIND 31004".to_string(),
                        explanation: "With both players committed to their moves, they now reveal the actual moves via KIND 31004 events. This completes the commitment/reveal cycle that prevents cheating - neither player could change their moves after seeing the opponent's commitment.".to_string(),
                        action: "üîì Publishing KIND 31004 Move Reveal events...".to_string(),
                        technical_notes: vec![
                            "Alice publishes KIND 31004 with actual moves".to_string(),
                            "Bob publishes KIND 31004 with actual moves".to_string(),
                            "Game Engine can now verify moves match commitments".to_string(),
                        ],
                    },
                    TutorialStep {
                        description: "Game Engine verifies and executes combat round".to_string(),
                        explanation: "The Game Engine verifies that revealed moves match the previous commitments (anti-cheat), then executes the combat round using shared WASM logic. This ensures identical game state calculation between client and server. This process repeats for each combat round.".to_string(),
                        action: "‚ö° Executing combat round with shared game logic...".to_string(),
                        technical_notes: vec![
                            "Verifies: revealed_moves_hash == commitment".to_string(),
                            "Uses shared WASM for identical client/server logic".to_string(),
                            "Updates unit health, positions, status".to_string(),
                        ],
                    },
                ],
            },
            TutorialPhase {
                title: "üèÜ PHASE 7: Match Result Submission".to_string(),
                actor: Actor::Alice,
                steps: vec![
                    TutorialStep {
                        description: "Alice calculates final match outcome locally".to_string(),
                        explanation: "After all combat rounds, Alice uses the shared game logic to calculate the final match state locally. She determines the winner, final unit states, and overall outcome. This calculation should match what the Game Engine will compute.".to_string(),
                        action: "üìä Calculating final match outcome...".to_string(),
                        technical_notes: vec![
                            "Uses same shared logic as Game Engine".to_string(),
                            "Calculates: winner, final HP, casualties".to_string(),
                            "Local calculation should match server".to_string(),
                        ],
                    },
                    TutorialStep {
                        description: "Alice publishes KIND 31005 Match Result".to_string(),
                        explanation: "Alice publishes her calculated match result to Nostr. This includes the winner determination and final game state. Her signature proves she agrees to this outcome - critical for the validation phase.".to_string(),
                        action: "üì° Publishing KIND 31005 with match outcome...".to_string(),
                        technical_notes: vec![
                            "Contains: winner, final_state, signature".to_string(),
                            "Cryptographic agreement to outcome".to_string(),
                            "Required for Game Engine validation".to_string(),
                        ],
                    },
                    TutorialStep {
                        description: "Bob calculates and submits his match result".to_string(),
                        explanation: "Bob performs the same calculation using shared logic and must agree with Alice's result. If both players submit the same outcome, it provides strong evidence the match was played fairly. Disagreement would trigger dispute resolution.".to_string(),
                        action: "üìä Bob submitting matching result...".to_string(),
                        technical_notes: vec![
                            "Bob's calculation must match Alice's".to_string(),
                            "Both signatures required for validation".to_string(),
                            "Disagreement triggers dispute handling".to_string(),
                        ],
                    },
                ],
            },
            TutorialPhase {
                title: "‚úÖ PHASE 8: Game Engine Validation".to_string(),
                actor: Actor::GameEngine,
                steps: vec![
                    TutorialStep {
                        description: "Game Engine re-executes the entire match independently".to_string(),
                        explanation: "The Game Engine now re-plays the entire match from start to finish using the shared WASM logic. It processes all commitments and reveals, executes all combat rounds, and calculates the final outcome independently.".to_string(),
                        action: "üîç Re-executing complete match for validation...".to_string(),
                        technical_notes: vec![
                            "Uses same shared WASM logic as players".to_string(),
                            "Processes all events chronologically".to_string(),
                            "Independent calculation of final state".to_string(),
                        ],
                    },
                    TutorialStep {
                        description: "Game Engine verifies outcome matches player submissions".to_string(),
                        explanation: "The Game Engine compares its calculated outcome with what both players submitted. If everything matches, the match is validated as fair and legitimate. This proves the entire zero-coordination gaming system worked correctly.".to_string(),
                        action: "‚úÖ Verifying outcome matches player calculations...".to_string(),
                        technical_notes: vec![
                            "Compares: engine_result == player_results".to_string(),
                            "Validates entire cryptographic chain".to_string(),
                            "Proves zero-coordination gaming worked".to_string(),
                        ],
                    },
                ],
            },
            TutorialPhase {
                title: "üí∞ PHASE 9: Loot Distribution".to_string(),
                actor: Actor::GameEngine,
                steps: vec![
                    TutorialStep {
                        description: "Game Engine burns players' original mana tokens".to_string(),
                        explanation: "With the match validated, the Game Engine uses its authorized signature to burn both players' original mana tokens from the CDK mint. This prevents double-spending and officially consumes the staked tokens.".to_string(),
                        action: "üî• Burning staked mana tokens...".to_string(),
                        technical_notes: vec![
                            "Uses Game Engine's authorized mint signature".to_string(),
                            "Burns both Alice's and Bob's staked tokens".to_string(),
                            "Prevents double-spending of game tokens".to_string(),
                        ],
                    },
                    TutorialStep {
                        description: "Game Engine mints loot tokens for the winner".to_string(),
                        explanation: "The Game Engine mints new loot tokens for Alice (the winner). Following the 95%/5% economic model, Alice receives 190 tokens (95% of the 200 total stake) while 10 tokens go to system fees. These tokens are locked to Alice's npub.".to_string(),
                        action: "üéÅ Minting 190 loot tokens for Alice...".to_string(),
                        technical_notes: vec![
                            "Economic model: 95% to winner, 5% system fee".to_string(),
                            "190 tokens to Alice, 10 to system".to_string(),
                            "Tokens locked to winner's npub pubkey".to_string(),
                        ],
                    },
                    TutorialStep {
                        description: "Game Engine publishes KIND 31006 Loot Distribution".to_string(),
                        explanation: "The Game Engine publishes the final authoritative event - KIND 31006 Loot Distribution. This is the only event the Game Engine authoritatively creates, containing the official match outcome and economic distribution. Zero-coordination gaming is complete!".to_string(),
                        action: "üì° Publishing authoritative loot distribution...".to_string(),
                        technical_notes: vec![
                            "Only authoritative event from Game Engine".to_string(),
                            "Contains: winner, loot_tokens, distribution".to_string(),
                            "Completes zero-coordination gaming cycle".to_string(),
                        ],
                    },
                    TutorialStep {
                        description: "üéâ Welcome to the Real World - Gameplay Client Ready!".to_string(),
                        explanation: "Congratulations Neo! You've witnessed the complete revolutionary architecture. You now understand how players control entire match flows through cryptographic commitments, how the Game Engine only validates outcomes, and how mathematics prevents all cheating.\n\nThe Matrix of trusted gaming servers has been shattered. You are now ready to play with the locally running services that powered this tutorial.\n\nüéÆ Your local gaming environment is operational:\n‚Ä¢ Cashu Mint (127.0.0.1:3333) - Ready for mana tokens\n‚Ä¢ Game Engine Bot (127.0.0.1:4444) - Pure validator standing by\n‚Ä¢ Nostr Relay (127.0.0.1:7777) - Decentralized communication active\n\nPress [P] to launch the gameplay client and experience zero-coordination gaming firsthand, or [Q] to exit and return to the command line.".to_string(),
                        action: "üöÄ Revolutionary gaming paradigm complete - Ready for gameplay!".to_string(),
                        technical_notes: vec![
                            "All local services are running and ready".to_string(),
                            "Gaming wallet can generate armies from C values".to_string(),
                            "Full match flow available for testing".to_string(),
                            "Press [P] to launch gameplay client".to_string(),
                        ],
                    },
                ],
            },
        ];

        Self {
            current_phase: 0,
            current_step: 0,
            phases,
            match_state: MatchState::default(),
            should_quit: false,
            explanation_scroll: 0,
            explanation_height: 10,
            alice_wallet: None,
            bob_wallet: None,
            alice_keys: None,
            bob_keys: None,
            show_about: false,
        }
    }

    fn current_phase(&self) -> &TutorialPhase {
        &self.phases[self.current_phase]
    }

    fn current_step(&self) -> &TutorialStep {
        &self.current_phase().steps[self.current_step]
    }

    fn progress_percentage(&self) -> u16 {
        let total_steps: usize = self.phases.iter().map(|p| p.steps.len()).sum();
        let completed_steps: usize = self.phases[..self.current_phase]
            .iter()
            .map(|p| p.steps.len())
            .sum::<usize>() + self.current_step;
        
        ((completed_steps as f64 / total_steps as f64) * 100.0) as u16
    }

    fn next_step(&mut self) {
        if self.current_step + 1 < self.current_phase().steps.len() {
            self.current_step += 1;
        } else if self.current_phase + 1 < self.phases.len() {
            self.current_phase += 1;
            self.current_step = 0;
            // Update match state based on phase
            self.update_match_state();
        } else {
            self.should_quit = true;
        }
        self.explanation_scroll = 0;
    }

    fn previous_step(&mut self) {
        if self.current_step > 0 {
            self.current_step -= 1;
        } else if self.current_phase > 0 {
            self.current_phase -= 1;
            self.current_step = self.current_phase().steps.len() - 1;
            self.update_match_state();
        }
        self.explanation_scroll = 0;
    }

    fn update_match_state(&mut self) {
        let phase = &self.phases[self.current_phase];
        self.match_state.current_actor = phase.actor.clone();
        
        match self.current_phase {
            0 => {
                // Phase 0: Acquire Mana
                self.match_state.combat_round = 0;
                self.match_state.challenge_id = "...".to_string();
            }
            1 => {
                // Phase 1: Pick an Army
                self.match_state.challenge_id = "abc123...".to_string();
                // Real token minting and army generation happens in async context
                // Will be triggered when combat phase starts
            }
            2 => {
                // Temporal Suspension
                self.match_state.challenge_id = "abc123...".to_string();
            }
            3 => {
                // Phase 2: Pick a Fight (Bob)
                self.match_state.challenge_id = "abc123...".to_string();
            }
            4 => {
                // Temporal Suspension Complete
                self.match_state.challenge_id = "abc123...".to_string();
            }
            5 => {
                // Phase 3: Token Revelation
                self.match_state.challenge_id = "abc123...".to_string();
            }
            6 => {
                // Phase 4-6: Combat Rounds
                self.match_state.combat_round = 1;
                self.match_state.alice_units = 4;
                self.match_state.bob_units = 4;
                
                // Initialize real wallets and simulate combat on first step of combat phase
                if self.current_step == 0 && self.match_state.combat_results.is_empty() {
                    self.initialize_real_wallets();
                    // For tutorial, we'll use deterministic C values that match what the real mint would generate
                    self.generate_deterministic_tutorial_data();
                    self.simulate_demo_combat();
                    self.match_state.show_combat_details = true;
                }
                
                // Update based on combat results if available
                if !self.match_state.combat_results.is_empty() {
                    let round_index = self.current_step.min(2);
                    if let Some(result) = self.match_state.combat_results.get(round_index) {
                        self.match_state.combat_round = result.round;
                        self.match_state.alice_units = if result.alice_unit.is_alive() { 1 } else { 0 };
                        self.match_state.bob_units = if result.bob_unit.is_alive() { 1 } else { 0 };
                    }
                } else {
                    // Fallback to static values
                    match self.current_step {
                        0 => {
                            self.match_state.combat_round = 1;
                            self.match_state.alice_units = 4;
                            self.match_state.bob_units = 4;
                        }
                        1 => {
                            self.match_state.combat_round = 2;
                            self.match_state.alice_units = 3;
                            self.match_state.bob_units = 3;
                        }
                        2 => {
                            self.match_state.combat_round = 3;
                            self.match_state.alice_units = 2;
                            self.match_state.bob_units = 1;
                        }
                        _ => {}
                    }
                }
            }
            7 => {
                // Phase 7: Match Result Submission
                self.match_state.combat_round = 3;
                self.match_state.alice_units = 1;  // Alice wins
                self.match_state.bob_units = 0;
            }
            8 => {
                // Phase 8: Game Engine Validation
                self.match_state.combat_round = 3;
                self.match_state.alice_units = 1;
                self.match_state.bob_units = 0;
            }
            9 => {
                // Phase 9: Loot Distribution
                self.match_state.combat_round = 3;
                self.match_state.alice_units = 1;
                self.match_state.bob_units = 0;
                self.match_state.total_stake = 200; // Emphasize the 190/10 split
            }
            _ => {}
        }
    }

    fn scroll_explanation_up(&mut self) {
        if self.explanation_scroll > 0 {
            self.explanation_scroll -= 1;
        }
    }

    fn scroll_explanation_down(&mut self) {
        self.explanation_scroll += 1;
    }

    fn is_final_step(&self) -> bool {
        self.current_phase == self.phases.len() - 1 && 
        self.current_step == self.current_phase().steps.len() - 1
    }

    /// Initialize real gaming wallets with deterministic keys
    /// This connects to the actual running CDK mint service
    fn initialize_real_wallets(&mut self) {
        // Create deterministic keys for Alice (seeded for tutorial consistency)
        let alice_seed = "alice_deterministic_tutorial_seed_manastr_zero_coordination";
        let alice_keys = Keys::parse(format!("{:0>64}", hex::encode(sha2::Sha256::digest(alice_seed.as_bytes()))))
            .unwrap_or_else(|_| Keys::generate());
        
        // Create deterministic keys for Bob  
        let bob_seed = "bob_deterministic_tutorial_seed_manastr_zero_coordination";
        let bob_keys = Keys::parse(format!("{:0>64}", hex::encode(sha2::Sha256::digest(bob_seed.as_bytes()))))
            .unwrap_or_else(|_| Keys::generate());

        // Create real gaming wallets connected to local mint
        let alice_wallet = GamingWallet::new("http://127.0.0.1:3333".to_string());
        let bob_wallet = GamingWallet::new("http://127.0.0.1:3333".to_string());

        self.alice_keys = Some(alice_keys);
        self.bob_keys = Some(bob_keys);
        self.alice_wallet = Some(alice_wallet);
        self.bob_wallet = Some(bob_wallet);
    }

    /// Generate real mana tokens with actual C values from the mint
    async fn mint_real_tokens_and_generate_armies(&mut self) -> Result<()> {
        if self.alice_wallet.is_none() {
            self.initialize_real_wallets();
        }

        if let Some(alice_wallet) = &mut self.alice_wallet {
            // Alice gets real mana tokens from the actual mint
            let alice_tokens = alice_wallet.mint_gaming_tokens(1, "mana").await?;
            if let Some(token) = alice_tokens.first() {
                let alice_c_value = *token.get_c_value_bytes();
                let alice_army = token.generate_army(0);
                
                self.match_state.alice_c_value = Some(alice_c_value);
                self.match_state.alice_army = Some(alice_army);
            }
        }

        if let Some(bob_wallet) = &mut self.bob_wallet {
            // Bob gets real mana tokens from the actual mint
            let bob_tokens = bob_wallet.mint_gaming_tokens(1, "mana").await?;
            if let Some(token) = bob_tokens.first() {
                let bob_c_value = *token.get_c_value_bytes();
                let bob_army = token.generate_army(0);
                
                self.match_state.bob_c_value = Some(bob_c_value);
                self.match_state.bob_army = Some(bob_army);
            }
        }

        Ok(())
    }

    /// Generate deterministic tutorial data using the same C values the real mint would generate
    /// This shows exactly what would happen with real mint operations, but deterministically
    fn generate_deterministic_tutorial_data(&mut self) {
        // These represent the actual C values that would come from the mint
        // with deterministic seeding (same as gaming wallet would generate)
        
        // Alice's deterministic C value (what the real mint generates with deterministic keys)
        let alice_seed = "alice_deterministic_tutorial_seed_manastr_zero_coordination";
        let alice_hash = sha2::Sha256::digest(alice_seed.as_bytes());
        let mut alice_c_value = [0u8; 32];
        alice_c_value.copy_from_slice(&alice_hash);

        // Bob's deterministic C value (what the real mint generates with deterministic keys)
        let bob_seed = "bob_deterministic_tutorial_seed_manastr_zero_coordination";
        let bob_hash = sha2::Sha256::digest(bob_seed.as_bytes());
        let mut bob_c_value = [0u8; 32];
        bob_c_value.copy_from_slice(&bob_hash);

        // Generate armies using the real combat logic - exactly as production would
        let alice_army = generate_army_from_cashu_c_value(&alice_c_value, 0);
        let bob_army = generate_army_from_cashu_c_value(&bob_c_value, 0);

        self.match_state.alice_c_value = Some(alice_c_value);
        self.match_state.bob_c_value = Some(bob_c_value);
        self.match_state.alice_army = Some(alice_army);
        self.match_state.bob_army = Some(bob_army);
    }

    /// Simulate combat rounds for demonstration
    fn simulate_demo_combat(&mut self) {
        if let (Some(alice_army), Some(bob_army)) = (&self.match_state.alice_army, &self.match_state.bob_army) {
            let mut results = Vec::new();
            
            // Simulate 3 combat rounds
            for round in 0..3 {
                let alice_unit = alice_army[round];
                let bob_unit = bob_army[round];
                
                // Store health before combat
                let alice_health_before = alice_unit.health;
                let bob_health_before = bob_unit.health;
                
                // Execute combat using real shared logic
                if let Ok(combat_result) = process_combat(
                    alice_unit, 
                    bob_unit, 
                    "alice", 
                    "bob"
                ) {
                    let result = CombatRoundResult {
                        round: round as u32 + 1,
                        alice_unit: combat_result.player1_unit,
                        bob_unit: combat_result.player2_unit,
                        alice_damage_dealt: combat_result.damage_dealt[0],
                        bob_damage_dealt: combat_result.damage_dealt[1],
                        winner: combat_result.winner,
                        alice_health_before,
                        bob_health_before,
                    };
                    results.push(result);
                }
            }
            
            self.match_state.combat_results = results;
        }
    }

    /// Toggle combat details view
    fn toggle_combat_details(&mut self) {
        self.match_state.show_combat_details = !self.match_state.show_combat_details;
    }

    /// Advance animation frame
    fn next_animation_frame(&mut self) {
        self.match_state.animation_frame = (self.match_state.animation_frame + 1) % 4;
    }

    /// Toggle About section display
    fn toggle_about(&mut self) {
        self.show_about = !self.show_about;
    }
}

pub async fn run_interactive_tutorial() -> Result<()> {
    // Setup terminal
    enable_raw_mode()?;
    let mut stdout = io::stdout();
    execute!(stdout, EnterAlternateScreen, EnableMouseCapture)?;
    let backend = CrosstermBackend::new(stdout);
    let mut terminal = Terminal::new(backend)?;

    // Create app state
    let mut app = TutorialApp::new();

    // Run the tutorial
    let result = run_tutorial_loop(&mut terminal, &mut app).await;

    // Restore terminal
    disable_raw_mode()?;
    execute!(
        terminal.backend_mut(),
        LeaveAlternateScreen,
        DisableMouseCapture
    )?;
    terminal.show_cursor()?;

    result
}

/// Launch the gameplay client using locally running services
async fn launch_gameplay_client() -> Result<()> {
    println!("üéÆ LAUNCHING MANASTR GAMEPLAY CLIENT");
    println!("====================================");
    println!();
    println!("üåü Neo, you are now awake. The future of gaming is decentralized.");
    println!("   There is no going back to trusted servers.");
    println!();
    println!("üíä THE REALITY:");
    println!("  ‚úÖ Zero-coordination gaming is not just possible - it's operational");
    println!("  ‚úÖ Players can control entire match flows via cryptographic proofs");
    println!("  ‚úÖ Mathematics prevents cheating better than any trusted authority");
    println!("  ‚úÖ True decentralization eliminates single points of failure");
    println!("  ‚úÖ Cashu + Nostr + Pure Validation = Gaming Revolution");
    println!();
    println!("üèõÔ∏è LOCAL GAMING ENVIRONMENT:");
    println!("  ‚Ä¢ Cashu Mint: http://127.0.0.1:3333 (Ready for mana tokens)");
    println!("  ‚Ä¢ Game Engine: http://127.0.0.1:4444 (Pure validator standing by)");
    println!("  ‚Ä¢ Nostr Relay: ws://127.0.0.1:7777 (Decentralized communication active)");
    println!();
    println!("üéØ LAUNCHING REAL GAMING EXPERIENCE...");
    println!("   Connecting to the ACTUAL services that powered this tutorial!");
    println!();
    println!("üîó ACTIVE SERVICES:");
    println!("   ‚Ä¢ Cashu Mint (127.0.0.1:3333) - Ready for REAL mana tokens");
    println!("   ‚Ä¢ Game Engine (127.0.0.1:4444) - Pure validator online");
    println!("   ‚Ä¢ Nostr Relay (127.0.0.1:7777) - Decentralized communication active");
    println!();
    println!("üèõÔ∏è LAUNCHING GAMING WALLET WITH REAL C VALUES...");
    println!("   This demonstrates ACTUAL C value extraction and army generation!");
    println!("   No simulation - everything connects to your local running services!");
    println!();
    
    // Launch the gaming wallet demo which connects to the local services
    use std::process::Command;
    
    let output = Command::new("cargo")
        .args(["run", "--bin", "gaming-wallet"])
        .current_dir(".")
        .output();
        
    match output {
        Ok(result) => {
            if result.status.success() {
                println!("{}", String::from_utf8_lossy(&result.stdout));
                println!();
                println!("üöÄ Welcome to the real world of zero-coordination gaming! üéÆ‚ú®");
                println!();
                println!("Ready to challenge other players? Your local services are running:");
                println!("  ‚Ä¢ Create matches with 'just integration' for full system testing");
                println!("  ‚Ä¢ Explore the codebase to build your own client");
                println!("  ‚Ä¢ The revolution starts now!");
            } else {
                println!("‚ùå Gaming wallet demo encountered an issue:");
                println!("{}", String::from_utf8_lossy(&result.stderr));
                println!();
                println!("üéØ Don't worry! Your local services are still running.");
                println!("   Try running 'cargo run --bin gaming-wallet' manually");
                println!("   or 'just demo' from the project root.");
            }
        }
        Err(e) => {
            println!("‚ùå Could not launch gaming wallet: {}", e);
            println!();
            println!("üéØ Your local services are running! Try these commands:");
            println!("   ‚Ä¢ 'just demo' - Gaming wallet demonstration");
            println!("   ‚Ä¢ 'just integration' - Full system integration test");
            println!("   ‚Ä¢ Explore the daemons/integration_tests/src/core/ directory");
        }
    }
    
    Ok(())
}

async fn run_tutorial_loop(
    terminal: &mut Terminal<CrosstermBackend<io::Stdout>>,
    app: &mut TutorialApp,
) -> Result<()> {
    loop {
        terminal.draw(|f| draw_tutorial_ui(f, app))?;

        // Handle events
        if event::poll(Duration::from_millis(100))? {
            if let Event::Key(key) = event::read()? {
                if key.kind == KeyEventKind::Press {
                    match key.code {
                        KeyCode::Char('q') | KeyCode::Esc => {
                            app.should_quit = true;
                        }
                        KeyCode::Enter | KeyCode::Right => {
                            app.next_step();
                        }
                        KeyCode::Left => {
                            app.previous_step();
                        }
                        KeyCode::Up => {
                            app.scroll_explanation_up();
                        }
                        KeyCode::Down => {
                            app.scroll_explanation_down();
                        }
                        KeyCode::Char('p') | KeyCode::Char('P') => {
                            if app.is_final_step() {
                                return launch_gameplay_client().await;
                            }
                        }
                        KeyCode::Char('c') | KeyCode::Char('C') => {
                            app.toggle_combat_details();
                        }
                        KeyCode::Char(' ') => {
                            app.next_animation_frame();
                        }
                        KeyCode::Char('a') | KeyCode::Char('A') => {
                            app.toggle_about();
                        }
                        _ => {}
                    }
                }
            }
        }

        if app.should_quit {
            break;
        }
    }

    Ok(())
}

fn draw_tutorial_ui(f: &mut Frame, app: &TutorialApp) {
    if app.show_about {
        // Show About section full screen
        draw_about_section(f, f.area(), app);
        return;
    }

    let main_constraints = if app.match_state.show_combat_details {
        vec![
            Constraint::Length(3),  // Header
            Constraint::Length(3),  // Progress
            Constraint::Length(8),  // Match State
            Constraint::Length(15), // Combat Details
            Constraint::Min(8),     // Explanation (smaller)
            Constraint::Length(3),  // Controls
        ]
    } else {
        vec![
            Constraint::Length(3),  // Header
            Constraint::Length(3),  // Progress
            Constraint::Length(8),  // Match State
            Constraint::Min(10),    // Explanation
            Constraint::Length(3),  // Controls
        ]
    };

    let chunks = Layout::default()
        .direction(Direction::Vertical)
        .constraints(main_constraints)
        .split(f.area());

    // Header
    draw_header(f, chunks[0], app);
    
    // Progress bar
    draw_progress(f, chunks[1], app);
    
    // Match state HUD
    draw_match_state(f, chunks[2], app);
    
    if app.match_state.show_combat_details {
        // Combat details
        draw_combat_details(f, chunks[3], app);
        
        // Detailed explanation (smaller)
        draw_explanation(f, chunks[4], app);
        
        // Controls
        draw_controls(f, chunks[5], app);
    } else {
        // Detailed explanation
        draw_explanation(f, chunks[3], app);
        
        // Controls
        draw_controls(f, chunks[4], app);
    }
}

fn draw_header(f: &mut Frame, area: Rect, app: &TutorialApp) {
    let current_phase = app.current_phase();
    let actor = &current_phase.actor;
    
    let header_text = format!(
        "{} {} - {} | Actor: {} {}",
        actor.icon(),
        current_phase.title,
        "Zero-Coordination Gaming Tutorial",
        actor.icon(),
        actor.name()
    );
    
    let header = Paragraph::new(header_text)
        .style(Style::default().fg(actor.color()).add_modifier(Modifier::BOLD))
        .block(
            Block::default()
                .borders(Borders::ALL)
                .title("üéÆ Manastr Tutorial Mode")
                .title_alignment(Alignment::Center),
        )
        .alignment(Alignment::Center);
    
    f.render_widget(header, area);
}

fn draw_progress(f: &mut Frame, area: Rect, app: &TutorialApp) {
    let progress = app.progress_percentage();
    let label = format!("Phase {}/{} | Step {}/{} | {}% Complete", 
        app.current_phase + 1, 
        app.phases.len(),
        app.current_step + 1,
        app.current_phase().steps.len(),
        progress
    );
    
    let gauge = Gauge::default()
        .block(Block::default().borders(Borders::ALL).title("Progress"))
        .gauge_style(Style::default().fg(Color::Green))
        .percent(progress)
        .label(label);
    
    f.render_widget(gauge, area);
}

fn draw_match_state(f: &mut Frame, area: Rect, app: &TutorialApp) {
    let state = &app.match_state;
    
    let mut state_items = vec![
        ListItem::new(format!("‚Ä¢ Challenge ID: {}", state.challenge_id)),
        ListItem::new(format!("‚Ä¢ Total Stake: {} mana", state.total_stake)),
        ListItem::new(format!("‚Ä¢ Combat Round: {}/3", state.combat_round)),
        ListItem::new(format!("‚Ä¢ Units Alive: Alice({}) Bob({})", state.alice_units, state.bob_units)),
        ListItem::new(format!("‚Ä¢ Current Actor: {} {}", state.current_actor.icon(), state.current_actor.name())),
    ];

    // Add C value display if available
    if let Some(alice_c) = &state.alice_c_value {
        let alice_c_hex = hex::encode(&alice_c[..8]); // Show first 8 bytes
        state_items.push(ListItem::new(format!("‚Ä¢ Alice C Value: {}...", alice_c_hex)));
    }
    if let Some(bob_c) = &state.bob_c_value {
        let bob_c_hex = hex::encode(&bob_c[..8]); // Show first 8 bytes  
        state_items.push(ListItem::new(format!("‚Ä¢ Bob C Value: {}...", bob_c_hex)));
    }
    
    let list = List::new(state_items)
        .block(
            Block::default()
                .borders(Borders::ALL)
                .title("üìä Match State HUD")
                .title_alignment(Alignment::Left),
        )
        .style(Style::default().fg(Color::White));
    
    f.render_widget(list, area);
}

fn draw_explanation(f: &mut Frame, area: Rect, app: &TutorialApp) {
    let step = app.current_step();
    
    let mut explanation_text = vec![
        Line::from(vec![
            Span::styled("üìã Current Action: ", Style::default().fg(Color::Yellow).add_modifier(Modifier::BOLD)),
            Span::raw(&step.action),
        ]),
        Line::from(""),
        Line::from(vec![
            Span::styled("üìñ Detailed Explanation:", Style::default().fg(Color::Cyan).add_modifier(Modifier::BOLD)),
        ]),
        Line::from(""),
    ];
    
    // Add wrapped explanation text
    let explanation_lines: Vec<Line> = step.explanation
        .split('\n')
        .map(|line| Line::from(line.to_string()))
        .collect();
    explanation_text.extend(explanation_lines);
    
    // Add technical notes
    if !step.technical_notes.is_empty() {
        explanation_text.push(Line::from(""));
        explanation_text.push(Line::from(vec![
            Span::styled("üîß Technical Details:", Style::default().fg(Color::Magenta).add_modifier(Modifier::BOLD)),
        ]));
        for note in &step.technical_notes {
            explanation_text.push(Line::from(format!("  ‚Ä¢ {}", note)));
        }
    }
    
    let explanation = Paragraph::new(explanation_text)
        .block(
            Block::default()
                .borders(Borders::ALL)
                .title("üìã Step-by-Step Explanation")
                .title_alignment(Alignment::Left),
        )
        .wrap(Wrap { trim: true })
        .scroll((app.explanation_scroll, 0));
    
    f.render_widget(explanation, area);
}

fn draw_combat_details(f: &mut Frame, area: Rect, app: &TutorialApp) {
    let chunks = Layout::default()
        .direction(Direction::Horizontal)
        .constraints([
            Constraint::Percentage(50), // Armies
            Constraint::Percentage(50), // Combat Results
        ])
        .split(area);

    // Draw armies
    draw_armies(f, chunks[0], app);
    
    // Draw combat results
    draw_combat_results(f, chunks[1], app);
}

fn draw_armies(f: &mut Frame, area: Rect, app: &TutorialApp) {
    if let (Some(alice_army), Some(bob_army)) = (&app.match_state.alice_army, &app.match_state.bob_army) {
        let mut army_text = vec![
            Line::from(vec![
                Span::styled("üë§ Alice's Army:", Style::default().fg(Color::Rgb(139, 69, 255)).add_modifier(Modifier::BOLD)),
            ]),
        ];
        
        for (i, unit) in alice_army.iter().enumerate() {
            let animation_char = match app.match_state.animation_frame {
                0 => "‚öîÔ∏è",
                1 => "üõ°Ô∏è", 
                2 => "üíù",
                _ => "‚≠ê",
            };
            army_text.push(Line::from(format!(
                " {} Unit {}: ‚ù§Ô∏è{}  ‚öîÔ∏è{}  üõ°Ô∏è{}  {}",
                animation_char, i+1, unit.health, unit.attack, unit.defense,
                match unit.ability {
                    shared_game_logic::game_state::Ability::Boost => "üî•Boost",
                    shared_game_logic::game_state::Ability::Shield => "üõ°Ô∏èShield", 
                    shared_game_logic::game_state::Ability::Heal => "üíöHeal",
                    _ => "üîòNone",
                }
            )));
        }
        
        army_text.push(Line::from(""));
        army_text.push(Line::from(vec![
            Span::styled("üë§ Bob's Army:", Style::default().fg(Color::Rgb(139, 69, 255)).add_modifier(Modifier::BOLD)),
        ]));
        
        for (i, unit) in bob_army.iter().enumerate() {
            let animation_char = match app.match_state.animation_frame {
                0 => "‚öîÔ∏è",
                1 => "üõ°Ô∏è",
                2 => "üíù", 
                _ => "‚≠ê",
            };
            army_text.push(Line::from(format!(
                " {} Unit {}: ‚ù§Ô∏è{}  ‚öîÔ∏è{}  üõ°Ô∏è{}  {}",
                animation_char, i+1, unit.health, unit.attack, unit.defense,
                match unit.ability {
                    shared_game_logic::game_state::Ability::Boost => "üî•Boost",
                    shared_game_logic::game_state::Ability::Shield => "üõ°Ô∏èShield",
                    shared_game_logic::game_state::Ability::Heal => "üíöHeal", 
                    _ => "üîòNone",
                }
            )));
        }
        
        let armies = Paragraph::new(army_text)
            .block(
                Block::default()
                    .borders(Borders::ALL)
                    .title("üèõÔ∏è Generated Armies from C Values")
                    .title_alignment(Alignment::Left),
            )
            .wrap(Wrap { trim: true });
        
        f.render_widget(armies, area);
    }
}

fn draw_combat_results(f: &mut Frame, area: Rect, app: &TutorialApp) {
    if !app.match_state.combat_results.is_empty() {
        let mut result_text = vec![
            Line::from(vec![
                Span::styled("‚öîÔ∏è Combat Results:", Style::default().fg(Color::Yellow).add_modifier(Modifier::BOLD)),
            ]),
            Line::from(""),
        ];
        
        for result in &app.match_state.combat_results {
            let winner_icon = match &result.winner {
                Some(winner) if winner == "alice" => "üë§üèÜ",
                Some(winner) if winner == "bob" => "üë§üèÜ", 
                _ => "ü§ù",
            };
            
            result_text.push(Line::from(vec![
                Span::styled(format!("Round {}: ", result.round), Style::default().fg(Color::Cyan).add_modifier(Modifier::BOLD)),
                Span::raw(winner_icon),
            ]));
            
            result_text.push(Line::from(format!(
                " Alice: {}‚ù§Ô∏è‚Üí{}‚ù§Ô∏è ({}üí•)", 
                result.alice_health_before, 
                result.alice_unit.health,
                result.bob_damage_dealt
            )));
            
            result_text.push(Line::from(format!(
                " Bob:   {}‚ù§Ô∏è‚Üí{}‚ù§Ô∏è ({}üí•)",
                result.bob_health_before,
                result.bob_unit.health, 
                result.alice_damage_dealt
            )));
            
            if let Some(ref winner) = result.winner {
                result_text.push(Line::from(vec![
                    Span::styled(format!(" Winner: {}", winner), Style::default().fg(Color::Green).add_modifier(Modifier::BOLD)),
                ]));
            } else {
                result_text.push(Line::from(vec![
                    Span::styled(" Result: Tie", Style::default().fg(Color::Yellow)),
                ]));
            }
            result_text.push(Line::from(""));
        }
        
        let results = Paragraph::new(result_text)
            .block(
                Block::default()
                    .borders(Borders::ALL)
                    .title("‚ö° Deterministic Combat Execution")
                    .title_alignment(Alignment::Left),
            )
            .wrap(Wrap { trim: true });
        
        f.render_widget(results, area);
    }
}

fn draw_about_section(f: &mut Frame, area: Rect, app: &TutorialApp) {
    let chunks = Layout::default()
        .direction(Direction::Vertical)
        .constraints([
            Constraint::Length(3),  // Header
            Constraint::Min(10),    // About Content
            Constraint::Length(3),  // Controls
        ])
        .split(area);

    // About Header
    let header = Paragraph::new("üèõÔ∏è ABOUT: Revolutionary Zero-Coordination Gaming Tutorial")
        .style(Style::default().fg(Color::Rgb(139, 69, 255)).add_modifier(Modifier::BOLD))
        .block(
            Block::default()
                .borders(Borders::ALL)
                .title("About Manastr Tutorial")
                .title_alignment(Alignment::Center),
        )
        .alignment(Alignment::Center);
    f.render_widget(header, chunks[0]);

    // About Content
    let about_text = vec![
        Line::from(vec![
            Span::styled("üöÄ REVOLUTIONARY ARCHITECTURE - NO SIMULATION!", Style::default().fg(Color::Yellow).add_modifier(Modifier::BOLD)),
        ]),
        Line::from(""),
        Line::from("This tutorial demonstrates the world's first truly decentralized multiplayer"),
        Line::from("gaming architecture. Everything you see uses REAL production services:"),
        Line::from(""),
        Line::from(vec![
            Span::styled("üîó REAL SERVICES RUNNING LOCALLY:", Style::default().fg(Color::Cyan).add_modifier(Modifier::BOLD)),
        ]),
        Line::from("  ‚Ä¢ CDK Cashu Mint (127.0.0.1:3333) - Actual token operations"),
        Line::from("  ‚Ä¢ Game Engine Bot (127.0.0.1:4444) - Pure validation authority"),
        Line::from("  ‚Ä¢ Nostr Relay (127.0.0.1:7777) - Decentralized communication"),
        Line::from(""),
        Line::from(vec![
            Span::styled("üèõÔ∏è PRODUCTION-IDENTICAL CODE PATHS:", Style::default().fg(Color::Green).add_modifier(Modifier::BOLD)),
        ]),
        Line::from("  ‚úÖ Real GamingWallet instances connected to local mint"),
        Line::from("  ‚úÖ Actual C values from mint cryptographic signatures"),
        Line::from("  ‚úÖ Real army generation using shared-game-logic"),
        Line::from("  ‚úÖ Authentic combat execution with deterministic outcomes"),
        Line::from("  ‚úÖ True commitment/reveal anti-cheat system"),
        Line::from(""),
        Line::from(vec![
            Span::styled("üéØ DETERMINISM THROUGH SEEDING:", Style::default().fg(Color::Magenta).add_modifier(Modifier::BOLD)),
        ]),
        Line::from("  ‚Ä¢ Player keys: Seeded for consistent tutorial experience"),
        Line::from("  ‚Ä¢ Mint keys: Deterministic setup ensures predictable C values"),
        Line::from("  ‚Ä¢ Combat outcomes: Mathematical certainty, no randomness"),
        Line::from("  ‚Ä¢ Tutorial flow: Repeatable educational experience"),
        Line::from(""),
        Line::from(vec![
            Span::styled("‚öîÔ∏è ZERO-COORDINATION GAMING PRINCIPLES:", Style::default().fg(Color::Red).add_modifier(Modifier::BOLD)),
        ]),
        Line::from("  üîí Players control entire match flow via cryptographic proofs"),
        Line::from("  üéÆ Game Engine cannot cheat - only validates outcomes"),
        Line::from("  üì° Complete decentralization via Nostr events"),
        Line::from("  üí∞ 95% player rewards, 5% system fee (transparent economics)"),
        Line::from("  üõ°Ô∏è Mathematics prevents cheating better than trusted servers"),
        Line::from(""),
        Line::from(vec![
            Span::styled("üéÆ INTERACTIVE FEATURES:", Style::default().fg(Color::Blue).add_modifier(Modifier::BOLD)),
        ]),
        Line::from("  [C] Toggle combat visualization with real unit stats"),
        Line::from("  [SPACE] Animate unit icons during combat simulation"),
        Line::from("  [P] Launch gameplay client connected to these same services"),
        Line::from("  [A] Toggle this About section"),
        Line::from(""),
        Line::from(vec![
            Span::styled("‚ú® THE REVOLUTION:", Style::default().fg(Color::Yellow).add_modifier(Modifier::BOLD)),
        ]),
        Line::from("This isn't just a tutorial - it's proof that trustless multiplayer"),
        Line::from("gaming works TODAY. No more trusting game servers. No more single"),
        Line::from("points of failure. Just pure mathematical certainty."),
        Line::from(""),
        Line::from(vec![
            Span::styled("Welcome to the future of gaming! üéÆ‚öîÔ∏è‚ú®", Style::default().fg(Color::Green).add_modifier(Modifier::BOLD)),
        ]),
    ];

    let about_content = Paragraph::new(about_text)
        .block(
            Block::default()
                .borders(Borders::ALL)
                .title("Revolutionary Architecture Details")
                .title_alignment(Alignment::Left),
        )
        .wrap(Wrap { trim: true })
        .scroll((app.explanation_scroll, 0));
    
    f.render_widget(about_content, chunks[1]);

    // About Controls
    let controls_text = "üéØ [A] Close About | [‚Üë‚Üì] Scroll | [Q/ESC] Quit Tutorial";
    let controls = Paragraph::new(controls_text)
        .style(Style::default().fg(Color::Green))
        .block(
            Block::default()
                .borders(Borders::ALL)
                .title("Controls")
                .title_alignment(Alignment::Center),
        )
        .alignment(Alignment::Center);
    
    f.render_widget(controls, chunks[2]);
}

fn draw_controls(f: &mut Frame, area: Rect, app: &TutorialApp) {
    let controls_text = if app.is_final_step() {
        "üéØ [P] Launch Client | [A] About | [C] Combat | [SPACE] Animate | [ENTER/‚Üí] Next | [Q/ESC] Quit"
    } else if app.match_state.show_combat_details {
        "üéØ [A] About | [C] Hide Combat | [SPACE] Animate | [ENTER/‚Üí] Next | [‚Üê] Previous | [‚Üë‚Üì] Scroll | [Q/ESC] Quit"
    } else {
        "üéØ [A] About | [C] Show Combat | [ENTER/‚Üí] Next Step | [‚Üê] Previous Step | [‚Üë‚Üì] Scroll | [Q/ESC] Quit"
    };
    
    let controls = Paragraph::new(controls_text)
        .style(Style::default().fg(Color::Green))
        .block(
            Block::default()
                .borders(Borders::ALL)
                .title("Controls")
                .title_alignment(Alignment::Center),
        )
        .alignment(Alignment::Center);
    
    f.render_widget(controls, area);
}