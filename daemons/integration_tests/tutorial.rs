use anyhow::Result;
use crossterm::{
    event::{self, DisableMouseCapture, EnableMouseCapture, Event, KeyCode, KeyEventKind},
    execute,
    terminal::{disable_raw_mode, enable_raw_mode, EnterAlternateScreen, LeaveAlternateScreen},
};
use ratatui::{
    backend::CrosstermBackend,
    layout::{Alignment, Constraint, Direction, Layout, Rect},
    style::{Color, Modifier, Style},
    text::{Line, Span},
    widgets::{
        Block, Borders, Gauge, List, ListItem, Paragraph, Wrap, Table, Row, Cell,
    },
    Frame, Terminal,
};
use std::io;
use tokio::time::Duration;
use shared_game_logic::{
    combat::{generate_army_from_cashu_c_value, process_combat},
    game_state::Unit,
};
use integration_tests::core::gaming_wallet::GamingWallet;
use nostr::Keys;
use sha2::Digest;

/// Tutorial application state
pub struct TutorialApp {
    current_phase: usize,
    current_step: usize,
    phases: Vec<TutorialPhase>,
    match_state: MatchState,
    should_quit: bool,
    explanation_scroll: u16,
    explanation_height: u16,
    // Real gaming wallets connected to local services
    alice_wallet: Option<GamingWallet>,
    bob_wallet: Option<GamingWallet>,
    alice_keys: Option<Keys>,
    bob_keys: Option<Keys>,
    show_about: bool,
    show_exit_confirmation: bool,
}

/// Individual tutorial phase
#[derive(Clone)]
pub struct TutorialPhase {
    title: String,
    actor: Actor,
    steps: Vec<TutorialStep>,
}

/// Individual step within a phase
#[derive(Clone)]
pub struct TutorialStep {
    description: String,
    explanation: String,
    action: String,
    technical_notes: Vec<String>,
    actor: Option<Actor>, // Override phase actor for specific steps
}

/// Current match state for HUD display
#[derive(Clone)]
pub struct MatchState {
    challenge_id: String,
    total_mana: u32,
    combat_round: u32,
    alice_units: u32,
    bob_units: u32,
    current_actor: Actor,
    // Real combat simulation data
    alice_c_value: Option<[u8; 32]>,
    bob_c_value: Option<[u8; 32]>,
    alice_army: Option<[Unit; 4]>,
    bob_army: Option<[Unit; 4]>,
    combat_results: Vec<CombatRoundResult>,
    animation_frame: u32,
    show_combat_details: bool,
}

/// Combat round result for animation
#[derive(Clone, Debug)]
pub struct CombatRoundResult {
    round: u32,
    alice_unit: Unit,
    bob_unit: Unit,
    alice_damage_dealt: u8,
    bob_damage_dealt: u8,
    winner: Option<String>,
    alice_health_before: u8,
    bob_health_before: u8,
}

/// Actor in the tutorial flow
#[derive(Clone, PartialEq)]
pub enum Actor {
    Alice,
    Bob,
    GameEngine,
    NostrRelay,
    CashuMint,
}

impl Actor {
    fn icon(&self) -> &str {
        match self {
            Actor::Alice => "ðŸ‘¤",
            Actor::Bob => "ðŸ‘¤",
            Actor::GameEngine => "ðŸŽ®",
            Actor::NostrRelay => "ðŸ“¡",
            Actor::CashuMint => "ðŸ¦",
        }
    }

    fn name(&self) -> &str {
        match self {
            Actor::Alice => "Alice",
            Actor::Bob => "Bob", 
            Actor::GameEngine => "Game Engine",
            Actor::NostrRelay => "Nostr Relay",
            Actor::CashuMint => "Cashu Mint",
        }
    }

    fn color(&self) -> Color {
        match self {
            Actor::Alice | Actor::Bob => Color::Rgb(139, 69, 255), // Purple for players
            Actor::NostrRelay => Color::Blue,                       // Blue for comms
            Actor::GameEngine | Actor::CashuMint => Color::Rgb(255, 153, 0), // Orange for authority
        }
    }
}

impl Default for MatchState {
    fn default() -> Self {
        Self {
            challenge_id: "abc123...".to_string(),
            total_mana: 200,
            combat_round: 1,
            alice_units: 4,
            bob_units: 4,
            current_actor: Actor::Alice,
            alice_c_value: None,
            bob_c_value: None,
            alice_army: None,
            bob_army: None,
            combat_results: Vec::new(),
            animation_frame: 0,
            show_combat_details: false,
        }
    }
}

impl TutorialApp {
    pub fn new() -> Self {
        let phases = vec![
            TutorialPhase {
                title: "ðŸš€ PHASE 0: Acquire Mana".to_string(),
                actor: Actor::Alice,
                steps: vec![
                    TutorialStep {
                        description: "Alice requests mana tokens from Game Engine's CDK mint".to_string(),
                        explanation: "In Manastr's revolutionary architecture, players acquire mana tokens from the Game Engine's Cashu mint. These tokens contain cryptographic randomness (C values) that players cannot manipulate, ensuring fair army generation.".to_string(),
                        action: "ðŸ¦ Requesting mana tokens with C values...".to_string(),
                        technical_notes: vec![
                            "C values are generated by mint's blinding process".to_string(),
                            "Neither mint nor player can bias this randomness".to_string(),
                            "Deterministic testing uses controlled mint keys".to_string(),
                        ],
                        actor: None,
                    },
                    TutorialStep {
                        description: "Alice unblinds mana to resolve C value paired with her x value".to_string(),
                        explanation: "The unblinding process reveals the C value - a 32-byte cryptographic proof that will be used to generate Alice's army. This value is authoritative randomness that neither the mint nor Alice could have predetermined.".to_string(),
                        action: "ðŸ”“ Unblinding mana token to extract C value...".to_string(),
                        technical_notes: vec![
                            "C = mint_signature * mint_pubkey (simplified)".to_string(),
                            "x is Alice's chosen blind factor".to_string(),
                            "Unblinding: proof = C * x^-1".to_string(),
                        ],
                        actor: None,
                    },
                ],
            },
            TutorialPhase {
                title: "ðŸš€ PHASE 1: Pick an Army".to_string(),
                actor: Actor::Alice,
                steps: vec![
                    TutorialStep {
                        description: "Alice generates her army from the Cashu C values".to_string(),
                        explanation: "The 32 bytes of the C value are decoded into army units using shared game logic. This is like drawing cards from a cryptographically shuffled deck - Alice now knows her units but no one else does. Different keysets could enable complex meta-protocols like MTG-style gameplay.".to_string(),
                        action: "âš”ï¸ Generating army from C value randomness...".to_string(),
                        technical_notes: vec![
                            "32 bytes â†’ 4 unit seeds (8 bytes each)".to_string(),
                            "Unit stats: HP, Attack, Defense, Speed".to_string(),
                            "Theming abstracted: Knights? Ninjas? Space Marines?".to_string(),
                        ],
                        actor: None,
                    },
                    TutorialStep {
                        description: "Alice creates SHA256 commitment of her army composition".to_string(),
                        explanation: "Alice commits to her army using a cryptographic hash. This commitment prevents her from changing her army later while keeping it secret from Bob. This is the foundation of the anti-cheat system - mathematical certainty instead of trust.".to_string(),
                        action: "ðŸ” Creating SHA256 commitment of army...".to_string(),
                        technical_notes: vec![
                            "commit = SHA256(army_units + nonce)".to_string(),
                            "Prevents army manipulation after seeing opponent".to_string(),
                            "Commitment/reveal scheme ensures fair play".to_string(),
                        ],
                        actor: None,
                    },
                    TutorialStep {
                        description: "Alice publishes KIND 21000 Game Challenge to Nostr".to_string(),
                        explanation: "Alice broadcasts her challenge to the decentralized Nostr network using a custom application event (21000+ range for Manastr). This event contains her army commitment, mana amount, and challenge terms. Each challenge creates a unique event that can be referenced by other players.".to_string(),
                        action: "ðŸ“¡ Publishing KIND 21000 Game Challenge event...".to_string(),
                        technical_notes: vec![
                            "Event includes: army_commitment, mana_amount, terms".to_string(),
                            "Cryptographically signed by Alice's key".to_string(),
                            "Can be created offline, published later".to_string(),
                        ],
                        actor: None,
                    },
                ],
            },
            TutorialPhase {
                title: "ðŸŒ€ Temporal Suspension".to_string(),
                actor: Actor::GameEngine,
                steps: vec![
                    TutorialStep {
                        description: "Nostr Relay has received and stored Alice's challenge event".to_string(),
                        explanation: "The beauty of this architecture: Alice's challenge is now permanently stored on the Nostr relay, available for any Game Engine to process. Multiple Game Engines could be running simultaneously, all processing the same events. The services run concurrently, not sequentially.".to_string(),
                        action: "ðŸ“¡ Challenge event stored in Nostr relay...".to_string(),
                        technical_notes: vec![
                            "Event permanently stored in Nostr relay".to_string(),
                            "Multiple Game Engines can process same events".to_string(),
                            "Services run concurrently, asynchronously".to_string(),
                        ],
                        actor: None,
                    },
                    TutorialStep {
                        description: "Game Engine validates challenge format and updates state to CHALLENGED".to_string(),
                        explanation: "The Game Engine acts as a pure validator, verifying the challenge format and signature. It updates its internal state machine but cannot manipulate the game outcome - it only validates what players have committed to cryptographically.".to_string(),
                        action: "âœ… Validating challenge and updating state machine...".to_string(),
                        technical_notes: vec![
                            "Validates: signature, format, mana amount".to_string(),
                            "State transition: NONE â†’ CHALLENGED".to_string(),
                            "Engine cannot manipulate player commitments".to_string(),
                        ],
                        actor: None,
                    },
                ],
            },
            TutorialPhase {
                title: "âš”ï¸ PHASE 2: Pick a Fight".to_string(),
                actor: Actor::Bob,
                steps: vec![
                    TutorialStep {
                        description: "Bob requests mana tokens and unblinds to get his C values".to_string(),
                        explanation: "Bob follows the same process as Alice - acquiring mana tokens from the Game Engine's mint and unblinding them to reveal his unique C values. Each player gets their own cryptographically random army composition.".to_string(),
                        action: "ðŸ¦ Bob acquiring mana and extracting C values...".to_string(),
                        technical_notes: vec![
                            "Same mint process as Alice".to_string(),
                            "Independent C values for Bob".to_string(),
                            "Deterministic for testing, random in production".to_string(),
                        ],
                        actor: None,
                    },
                    TutorialStep {
                        description: "Bob generates his army and creates commitment".to_string(),
                        explanation: "Bob's army is generated from his unique C values using the same shared game logic as Alice. He then creates his own SHA256 commitment. Both players now have committed to their armies without revealing them.".to_string(),
                        action: "âš”ï¸ Bob generating army and creating commitment...".to_string(),
                        technical_notes: vec![
                            "Uses same army generation algorithm".to_string(),
                            "Independent commitment: SHA256(bob_army + nonce)".to_string(),
                            "Both armies now committed but secret".to_string(),
                        ],
                        actor: None,
                    },
                    TutorialStep {
                        description: "Bob publishes KIND 21001 Game Acceptance to Nostr".to_string(),
                        explanation: "Bob accepts Alice's challenge by publishing his own Nostr event. This contains his army commitment and confirms his mana amount. The event references Alice's challenge via an 'e' tag - now both players have committed armies and the match is official.".to_string(),
                        action: "ðŸ“¡ Publishing KIND 21001 Game Acceptance...".to_string(),
                        technical_notes: vec![
                            "References Alice's challenge event ID".to_string(),
                            "Contains Bob's army commitment".to_string(),
                            "Confirms mana amount matching Alice's terms".to_string(),
                        ],
                        actor: None,
                    },
                ],
            },
            TutorialPhase {
                title: "ðŸŒ€ Temporal Suspension Complete".to_string(),
                actor: Actor::GameEngine,
                steps: vec![
                    TutorialStep {
                        description: "Nostr Relay has both challenge and acceptance events available".to_string(),
                        explanation: "Both Alice's challenge and Bob's acceptance are now stored in the Nostr relay. The Game Engine can process these events when ready - there's no rush. The cryptographic commitments ensure the integrity of the match state regardless of processing timing.".to_string(),
                        action: "ðŸ“¡ Both events available for Game Engine processing...".to_string(),
                        technical_notes: vec![
                            "Challenge and acceptance events both stored".to_string(),
                            "Game Engine processes at its own pace".to_string(),
                            "Cryptographic integrity maintained throughout".to_string(),
                        ],
                        actor: None,
                    },
                    TutorialStep {
                        description: "Game Engine processes both events and updates state to ACCEPTED".to_string(),
                        explanation: "The Game Engine validates both the challenge and acceptance events, verifies commitment formats, and updates the match state. Both players have now committed to their armies cryptographically - the match is officially underway.".to_string(),
                        action: "âœ… Processing both events and updating match state...".to_string(),
                        technical_notes: vec![
                            "Validates both Alice's and Bob's signatures".to_string(),
                            "State transition: NONE â†’ CHALLENGED â†’ ACCEPTED".to_string(),
                            "Both army commitments now locked in".to_string(),
                        ],
                        actor: None,
                    },
                ],
            },
            TutorialPhase {
                title: "ðŸ”“ PHASE 3: Token Revelation".to_string(),
                actor: Actor::Alice,
                steps: vec![
                    TutorialStep {
                        description: "Alice reveals her actual Cashu tokens via KIND 21002".to_string(),
                        explanation: "Now Alice must reveal her actual Cashu tokens that were used to generate her army. This allows the Game Engine to verify that her army commitment was generated honestly from real C values, not fabricated.".to_string(),
                        action: "ðŸŽ« Publishing KIND 21002 Token Reveal...".to_string(),
                        technical_notes: vec![
                            "Reveals: token proofs, C values, x values".to_string(),
                            "Allows army verification without revealing units".to_string(),
                            "Prevents fake army commitments".to_string(),
                        ],
                        actor: None,
                    },
                    TutorialStep {
                        description: "Bob reveals his actual Cashu tokens via KIND 21002".to_string(),
                        explanation: "Bob follows the same process, revealing his Cashu tokens. Both players have now provided the cryptographic proofs needed for the Game Engine to verify their armies were generated fairly.".to_string(),
                        action: "ðŸŽ« Bob publishing KIND 21002 Token Reveal...".to_string(),
                        technical_notes: vec![
                            "Bob's token revelation follows same format".to_string(),
                            "Both players now have verifiable armies".to_string(),
                            "Game Engine can re-generate armies to check".to_string(),
                        ],
                        actor: Some(Actor::Bob),
                    },
                    TutorialStep {
                        description: "Game Engine verifies tokens and re-generates armies".to_string(),
                        explanation: "The Game Engine queries the Cashu mint to verify both players' tokens are valid and unspent, then re-generates their armies from the revealed C values. It verifies these match the original commitments - catching any cheating attempts.".to_string(),
                        action: "ðŸ” Verifying tokens and army commitments...".to_string(),
                        technical_notes: vec![
                            "Queries mint: are tokens valid and unspent?".to_string(),
                            "Re-generates armies from C values".to_string(),
                            "Verifies: generated_army_hash == commitment".to_string(),
                        ],
                        actor: None,
                    },
                    TutorialStep {
                        description: "Match state updated to IN_COMBAT - battle begins!".to_string(),
                        explanation: "With both armies verified as legitimate, the Game Engine updates the match state to IN_COMBAT. The cryptographic foundations are complete - now the tactical battle can begin with mathematical certainty of fairness.".to_string(),
                        action: "âš”ï¸ Transitioning to combat phase...".to_string(),
                        technical_notes: vec![
                            "State transition: ACCEPTED â†’ IN_COMBAT".to_string(),
                            "Both armies verified and ready".to_string(),
                            "Combat can proceed with anti-cheat guarantees".to_string(),
                        ],
                        actor: None,
                    },
                ],
            },
            TutorialPhase {
                title: "âš”ï¸ PHASE 4-6: Combat Simulation (3 Rounds)".to_string(),
                actor: Actor::Alice,
                steps: vec![
                    TutorialStep {
                        description: "Alice (challenger) publishes her move via KIND 21003".to_string(),
                        explanation: "Combat uses turn-based system with event chaining. Alice goes first as the challenger and publishes her tactical moves directly to Nostr. Each move event references the previous event hash, creating an immutable chain that prevents tampering and ensures chronological order.".to_string(),
                        action: "âš”ï¸ Publishing KIND 21003 Combat Move...".to_string(),
                        technical_notes: vec![
                            "Challenger (Alice) always moves first".to_string(),
                            "Event references previous game event hash".to_string(),
                            "Turn-based system with event chaining".to_string(),
                        ],
                        actor: None,
                    },
                    TutorialStep {
                        description: "Bob responds with his counter-move via KIND 21003".to_string(),
                        explanation: "Bob sees Alice's move and publishes his response. His event references Alice's move event hash, maintaining the chronological chain. This turn-based approach allows strategic responses while preserving the immutable event history for validation.".to_string(),
                        action: "ðŸ›¡ï¸ Bob publishing KIND 21003 Counter-Move...".to_string(),
                        technical_notes: vec![
                            "References Alice's move event hash".to_string(),
                            "Maintains chronological event chain".to_string(),
                            "Turn-based tactical gameplay".to_string(),
                        ],
                        actor: Some(Actor::Bob),
                    },
                    TutorialStep {
                        description: "ðŸŒ€ðŸŒ€ðŸŒ€ Game Engine processes the combat round".to_string(),
                        explanation: "The Game Engine validates the event chain and executes the combat round using shared game engine logic. It processes Alice's move, then Bob's counter-move, calculating damage and effects. The chronological event chain ensures fair play without complex commitment schemes.".to_string(),
                        action: "ðŸŒ€ Processing combat round with event chain validation...".to_string(),
                        technical_notes: vec![
                            "Validates event chain chronological order".to_string(),
                            "Executes combat with shared game engine logic".to_string(),
                            "Updates unit states and round results".to_string(),
                        ],
                        actor: Some(Actor::GameEngine),
                    },
                ],
            },
            TutorialPhase {
                title: "ðŸ† PHASE 7: Match Result Submission".to_string(),
                actor: Actor::Alice,
                steps: vec![
                    TutorialStep {
                        description: "Alice calculates final match outcome locally".to_string(),
                        explanation: "After all combat rounds, Alice uses the shared game logic to calculate the final match state locally. She determines the winner, final unit states, and overall outcome. This calculation should match what the Game Engine will compute.".to_string(),
                        action: "ðŸ“Š Calculating final match outcome...".to_string(),
                        technical_notes: vec![
                            "Uses same shared logic as Game Engine".to_string(),
                            "Calculates: winner, final HP, casualties".to_string(),
                            "Local calculation should match server".to_string(),
                        ],
                        actor: None,
                    },
                    TutorialStep {
                        description: "Alice publishes KIND 21004 Match Result".to_string(),
                        explanation: "Alice publishes her calculated match result to Nostr. This includes the winner determination and final game state. Her signature proves she agrees to this outcome - critical for the validation phase.".to_string(),
                        action: "ðŸ“¡ Publishing KIND 21004 with match outcome...".to_string(),
                        technical_notes: vec![
                            "Contains: winner, final_state, signature".to_string(),
                            "Cryptographic agreement to outcome".to_string(),
                            "Required for Game Engine validation".to_string(),
                        ],
                        actor: None,
                    },
                    TutorialStep {
                        description: "Bob calculates and submits his match result".to_string(),
                        explanation: "Bob performs the same calculation using shared logic and must agree with Alice's result. If both players submit the same outcome, it provides strong evidence the match was played fairly. Disagreement would trigger dispute resolution.".to_string(),
                        action: "ðŸ“Š Bob submitting matching result...".to_string(),
                        technical_notes: vec![
                            "Bob's calculation must match Alice's".to_string(),
                            "Both signatures required for validation".to_string(),
                            "Disagreement triggers dispute handling".to_string(),
                        ],
                        actor: Some(Actor::Bob),
                    },
                ],
            },
            TutorialPhase {
                title: "âœ… PHASE 8: Game Engine Validation".to_string(),
                actor: Actor::GameEngine,
                steps: vec![
                    TutorialStep {
                        description: "Game Engine re-executes the entire match independently".to_string(),
                        explanation: "The Game Engine now re-plays the entire match from start to finish using the shared WASM logic. It processes all commitments and reveals, executes all combat rounds, and calculates the final outcome independently.".to_string(),
                        action: "ðŸ” Re-executing complete match for validation...".to_string(),
                        technical_notes: vec![
                            "Uses same shared WASM logic as players".to_string(),
                            "Processes all events chronologically".to_string(),
                            "Independent calculation of final state".to_string(),
                        ],
                        actor: None,
                    },
                    TutorialStep {
                        description: "Game Engine verifies outcome matches player submissions".to_string(),
                        explanation: "The Game Engine compares its calculated outcome with what both players submitted. If everything matches, the match is validated as fair and legitimate. This proves the entire zero-coordination gaming system worked correctly.".to_string(),
                        action: "âœ… Verifying outcome matches player calculations...".to_string(),
                        technical_notes: vec![
                            "Compares: engine_result == player_results".to_string(),
                            "Validates entire cryptographic chain".to_string(),
                            "Proves zero-coordination gaming worked".to_string(),
                        ],
                        actor: None,
                    },
                ],
            },
            TutorialPhase {
                title: "ðŸ’° PHASE 9: Loot Distribution".to_string(),
                actor: Actor::GameEngine,
                steps: vec![
                    TutorialStep {
                        description: "Game Engine burns players' original mana tokens".to_string(),
                        explanation: "With the match validated, the Game Engine uses its authorized signature to burn both players' original mana tokens from the CDK mint. This prevents double-spending and officially consumes the wagered tokens.".to_string(),
                        action: "ðŸ”¥ Burning wagered mana tokens...".to_string(),
                        technical_notes: vec![
                            "Uses Game Engine's authorized mint signature".to_string(),
                            "Burns both Alice's and Bob's wagered tokens".to_string(),
                            "Prevents double-spending of game tokens".to_string(),
                        ],
                        actor: None,
                    },
                    TutorialStep {
                        description: "Game Engine mints loot tokens for the winner".to_string(),
                        explanation: "The Game Engine mints new loot tokens for Alice (the winner). Following the 95%/5% economic model, Alice receives 190 tokens (95% of the 200 total mana) while 10 tokens go to system fees. These tokens are locked to Alice's npub.".to_string(),
                        action: "ðŸŽ Minting 190 loot tokens for Alice...".to_string(),
                        technical_notes: vec![
                            "Economic model: 95% to winner, 5% system fee".to_string(),
                            "190 tokens to Alice, 10 to system".to_string(),
                            "Tokens locked to winner's npub pubkey".to_string(),
                        ],
                        actor: None,
                    },
                    TutorialStep {
                        description: "ðŸŒ€ðŸŒ€ðŸŒ€ Game Engine publishes KIND 21005 Loot Distribution".to_string(),
                        explanation: "The Game Engine publishes the final authoritative event - KIND 21005 Loot Distribution. This is the only event the Game Engine authoritatively creates, containing the official match outcome and economic distribution. Zero-coordination gaming is complete!".to_string(),
                        action: "ðŸ“¡ Publishing authoritative loot distribution...".to_string(),
                        technical_notes: vec![
                            "Only authoritative event from Game Engine".to_string(),
                            "Contains: winner, loot_tokens, distribution".to_string(),
                            "Completes zero-coordination gaming cycle".to_string(),
                        ],
                        actor: Some(Actor::GameEngine),
                    },
                    TutorialStep {
                        description: "ðŸŽ‰ Zero-Coordination Gaming Revolution Complete!".to_string(),
                        explanation: "Congratulations Neo! You've witnessed the complete revolutionary architecture. You now understand how players control entire match flows through cryptographic commitments, how the Game Engine only validates outcomes, and how mathematics prevents all cheating.\n\nThe Matrix of trusted gaming servers has been shattered. This architecture enables:\n\nðŸ”’ **Cryptographic Security**: Mathematics prevents cheating better than any trusted authority\nðŸ“¡ **Complete Decentralization**: No single point of failure or control\nðŸŽ® **Player Sovereignty**: You control the entire match flow via Nostr events\nâš¡ **Zero Coordination**: No central matchmaking or trusted intermediaries needed\n\nThe future of gaming is decentralized, and it starts now!\n\nPress [Q] to exit the tutorial.".to_string(),
                        action: "ðŸš€ Revolutionary gaming paradigm complete!".to_string(),
                        technical_notes: vec![
                            "Zero-coordination gaming architecture operational".to_string(),
                            "Cryptographic anti-cheat system proven".to_string(),
                            "Player-driven match flow demonstrated".to_string(),
                            "Decentralized gaming revolution achieved".to_string(),
                        ],
                        actor: None,
                    },
                ],
            },
        ];

        Self {
            current_phase: 0,
            current_step: 0,
            phases,
            match_state: MatchState::default(),
            should_quit: false,
            explanation_scroll: 0,
            explanation_height: 10,
            alice_wallet: None,
            bob_wallet: None,
            alice_keys: None,
            bob_keys: None,
            show_about: false,
            show_exit_confirmation: false,
        }
    }

    fn current_phase(&self) -> &TutorialPhase {
        &self.phases[self.current_phase]
    }

    fn current_step(&self) -> &TutorialStep {
        &self.current_phase().steps[self.current_step]
    }

    fn progress_percentage(&self) -> u16 {
        let total_steps: usize = self.phases.iter().map(|p| p.steps.len()).sum();
        let completed_steps: usize = self.phases[..self.current_phase]
            .iter()
            .map(|p| p.steps.len())
            .sum::<usize>() + self.current_step;
        
        ((completed_steps as f64 / total_steps as f64) * 100.0) as u16
    }

    fn next_step(&mut self) {
        if self.current_step + 1 < self.current_phase().steps.len() {
            self.current_step += 1;
        } else if self.current_phase + 1 < self.phases.len() {
            self.current_phase += 1;
            self.current_step = 0;
            // Update match state based on phase
            self.update_match_state();
        } else {
            self.should_quit = true;
        }
        self.explanation_scroll = 0;
    }

    fn previous_step(&mut self) {
        if self.current_step > 0 {
            self.current_step -= 1;
        } else if self.current_phase > 0 {
            self.current_phase -= 1;
            self.current_step = self.current_phase().steps.len() - 1;
            self.update_match_state();
        }
        self.explanation_scroll = 0;
    }

    fn update_match_state(&mut self) {
        let phase = &self.phases[self.current_phase];
        self.match_state.current_actor = phase.actor.clone();
        
        match self.current_phase {
            0 => {
                // Phase 0: Acquire Mana
                self.match_state.combat_round = 0;
                self.match_state.challenge_id = "...".to_string();
            }
            1 => {
                // Phase 1: Pick an Army
                self.match_state.challenge_id = "abc123...".to_string();
                // Real token minting and army generation happens in async context
                // Will be triggered when combat phase starts
            }
            2 => {
                // Temporal Suspension
                self.match_state.challenge_id = "abc123...".to_string();
            }
            3 => {
                // Phase 2: Pick a Fight (Bob)
                self.match_state.challenge_id = "abc123...".to_string();
            }
            4 => {
                // Temporal Suspension Complete
                self.match_state.challenge_id = "abc123...".to_string();
            }
            5 => {
                // Phase 3: Token Revelation
                self.match_state.challenge_id = "abc123...".to_string();
            }
            6 => {
                // Phase 4-6: Combat Rounds
                self.match_state.combat_round = 1;
                self.match_state.alice_units = 4;
                self.match_state.bob_units = 4;
                
                // Initialize real wallets and simulate combat on first step of combat phase
                if self.current_step == 0 && self.match_state.combat_results.is_empty() {
                    self.initialize_real_wallets();
                    // For tutorial, we'll use deterministic C values that match what the real mint would generate
                    self.generate_deterministic_tutorial_data();
                    self.simulate_demo_combat();
                    self.match_state.show_combat_details = true;
                }
                
                // Update based on combat results if available
                if !self.match_state.combat_results.is_empty() {
                    let round_index = self.current_step.min(2);
                    if let Some(result) = self.match_state.combat_results.get(round_index) {
                        self.match_state.combat_round = result.round;
                        self.match_state.alice_units = if result.alice_unit.is_alive() { 1 } else { 0 };
                        self.match_state.bob_units = if result.bob_unit.is_alive() { 1 } else { 0 };
                    }
                } else {
                    // Fallback to static values
                    match self.current_step {
                        0 => {
                            self.match_state.combat_round = 1;
                            self.match_state.alice_units = 4;
                            self.match_state.bob_units = 4;
                        }
                        1 => {
                            self.match_state.combat_round = 2;
                            self.match_state.alice_units = 3;
                            self.match_state.bob_units = 3;
                        }
                        2 => {
                            self.match_state.combat_round = 3;
                            self.match_state.alice_units = 2;
                            self.match_state.bob_units = 1;
                        }
                        _ => {}
                    }
                }
            }
            7 => {
                // Phase 7: Match Result Submission
                self.match_state.combat_round = 3;
                self.match_state.alice_units = 1;  // Alice wins
                self.match_state.bob_units = 0;
            }
            8 => {
                // Phase 8: Game Engine Validation
                self.match_state.combat_round = 3;
                self.match_state.alice_units = 1;
                self.match_state.bob_units = 0;
            }
            9 => {
                // Phase 9: Loot Distribution
                self.match_state.combat_round = 3;
                self.match_state.alice_units = 1;
                self.match_state.bob_units = 0;
                self.match_state.total_mana = 200; // Emphasize the 190/10 split
            }
            _ => {}
        }
    }

    fn scroll_explanation_up(&mut self) {
        if self.explanation_scroll > 0 {
            self.explanation_scroll -= 1;
        }
    }

    fn scroll_explanation_down(&mut self) {
        self.explanation_scroll += 1;
    }

    fn is_final_step(&self) -> bool {
        self.current_phase == self.phases.len() - 1 && 
        self.current_step == self.current_phase().steps.len() - 1
    }

    /// Initialize real gaming wallets with deterministic keys
    /// This connects to the actual running CDK mint service
    fn initialize_real_wallets(&mut self) {
        // Create deterministic keys for Alice (seeded for tutorial consistency)
        let alice_seed = "alice_deterministic_tutorial_seed_manastr_zero_coordination";
        let alice_keys = Keys::parse(format!("{:0>64}", hex::encode(sha2::Sha256::digest(alice_seed.as_bytes()))))
            .unwrap_or_else(|_| Keys::generate());
        
        // Create deterministic keys for Bob  
        let bob_seed = "bob_deterministic_tutorial_seed_manastr_zero_coordination";
        let bob_keys = Keys::parse(format!("{:0>64}", hex::encode(sha2::Sha256::digest(bob_seed.as_bytes()))))
            .unwrap_or_else(|_| Keys::generate());

        // Create real gaming wallets connected to local mint
        let alice_wallet = GamingWallet::new("http://127.0.0.1:3333".to_string());
        let bob_wallet = GamingWallet::new("http://127.0.0.1:3333".to_string());

        self.alice_keys = Some(alice_keys);
        self.bob_keys = Some(bob_keys);
        self.alice_wallet = Some(alice_wallet);
        self.bob_wallet = Some(bob_wallet);
    }

    /// Generate real mana tokens with actual C values from the mint
    async fn mint_real_tokens_and_generate_armies(&mut self) -> Result<()> {
        if self.alice_wallet.is_none() {
            self.initialize_real_wallets();
        }

        if let Some(alice_wallet) = &mut self.alice_wallet {
            // Alice gets real mana tokens from the actual mint
            let alice_tokens = alice_wallet.mint_gaming_tokens(1, "mana").await?;
            if let Some(token) = alice_tokens.first() {
                let alice_c_value = *token.get_c_value_bytes();
                let alice_army = token.generate_army(0);
                
                self.match_state.alice_c_value = Some(alice_c_value);
                self.match_state.alice_army = Some(alice_army);
            }
        }

        if let Some(bob_wallet) = &mut self.bob_wallet {
            // Bob gets real mana tokens from the actual mint
            let bob_tokens = bob_wallet.mint_gaming_tokens(1, "mana").await?;
            if let Some(token) = bob_tokens.first() {
                let bob_c_value = *token.get_c_value_bytes();
                let bob_army = token.generate_army(0);
                
                self.match_state.bob_c_value = Some(bob_c_value);
                self.match_state.bob_army = Some(bob_army);
            }
        }

        Ok(())
    }

    /// Generate deterministic tutorial data using the same C values the real mint would generate
    /// This shows exactly what would happen with real mint operations, but deterministically
    fn generate_deterministic_tutorial_data(&mut self) {
        // These represent the actual C values that would come from the mint
        // with deterministic seeding (same as gaming wallet would generate)
        
        // Alice's deterministic C value (what the real mint generates with deterministic keys)
        let alice_seed = "alice_deterministic_tutorial_seed_manastr_zero_coordination";
        let alice_hash = sha2::Sha256::digest(alice_seed.as_bytes());
        let mut alice_c_value = [0u8; 32];
        alice_c_value.copy_from_slice(&alice_hash);

        // Bob's deterministic C value (what the real mint generates with deterministic keys)
        let bob_seed = "bob_deterministic_tutorial_seed_manastr_zero_coordination";
        let bob_hash = sha2::Sha256::digest(bob_seed.as_bytes());
        let mut bob_c_value = [0u8; 32];
        bob_c_value.copy_from_slice(&bob_hash);

        // Generate armies using the real combat logic - exactly as production would
        let alice_army = generate_army_from_cashu_c_value(&alice_c_value, 0);
        let bob_army = generate_army_from_cashu_c_value(&bob_c_value, 0);

        self.match_state.alice_c_value = Some(alice_c_value);
        self.match_state.bob_c_value = Some(bob_c_value);
        self.match_state.alice_army = Some(alice_army);
        self.match_state.bob_army = Some(bob_army);
    }

    /// Simulate combat rounds for demonstration
    fn simulate_demo_combat(&mut self) {
        if let (Some(alice_army), Some(bob_army)) = (&self.match_state.alice_army, &self.match_state.bob_army) {
            let mut results = Vec::new();
            
            // Simulate 3 combat rounds
            for round in 0..3 {
                let alice_unit = alice_army[round];
                let bob_unit = bob_army[round];
                
                // Store health before combat
                let alice_health_before = alice_unit.health;
                let bob_health_before = bob_unit.health;
                
                // Execute combat using real shared logic
                if let Ok(combat_result) = process_combat(
                    alice_unit, 
                    bob_unit, 
                    "alice", 
                    "bob"
                ) {
                    let result = CombatRoundResult {
                        round: round as u32 + 1,
                        alice_unit: combat_result.player1_unit,
                        bob_unit: combat_result.player2_unit,
                        alice_damage_dealt: combat_result.damage_dealt[0],
                        bob_damage_dealt: combat_result.damage_dealt[1],
                        winner: combat_result.winner,
                        alice_health_before,
                        bob_health_before,
                    };
                    results.push(result);
                }
            }
            
            self.match_state.combat_results = results;
        }
    }

    /// Toggle combat details view
    fn toggle_combat_details(&mut self) {
        self.match_state.show_combat_details = !self.match_state.show_combat_details;
    }

    /// Advance animation frame
    fn next_animation_frame(&mut self) {
        self.match_state.animation_frame = (self.match_state.animation_frame + 1) % 4;
    }

    /// Toggle About section display
    fn toggle_about(&mut self) {
        self.show_about = !self.show_about;
    }

    /// Show exit confirmation dialog
    fn show_exit_confirmation(&mut self) {
        self.show_exit_confirmation = true;
    }

    /// Hide exit confirmation dialog
    fn hide_exit_confirmation(&mut self) {
        self.show_exit_confirmation = false;
    }
}

pub async fn run_interactive_tutorial() -> Result<()> {
    // Setup terminal
    enable_raw_mode()?;
    let mut stdout = io::stdout();
    execute!(stdout, EnterAlternateScreen, EnableMouseCapture)?;
    let backend = CrosstermBackend::new(stdout);
    let mut terminal = Terminal::new(backend)?;

    // Create app state
    let mut app = TutorialApp::new();

    // Run the tutorial
    let result = run_tutorial_loop(&mut terminal, &mut app).await;

    // Restore terminal
    disable_raw_mode()?;
    execute!(
        terminal.backend_mut(),
        LeaveAlternateScreen,
        DisableMouseCapture
    )?;
    terminal.show_cursor()?;

    result
}


async fn run_tutorial_loop(
    terminal: &mut Terminal<CrosstermBackend<io::Stdout>>,
    app: &mut TutorialApp,
) -> Result<()> {
    loop {
        terminal.draw(|f| draw_tutorial_ui(f, app))?;

        // Handle events
        if event::poll(Duration::from_millis(100))? {
            if let Event::Key(key) = event::read()? {
                if key.kind == KeyEventKind::Press {
                    match key.code {
                        KeyCode::Char('q') | KeyCode::Esc => {
                            if app.show_exit_confirmation {
                                app.hide_exit_confirmation();
                            } else {
                                app.show_exit_confirmation();
                            }
                        }
                        KeyCode::Char('y') | KeyCode::Char('Y') => {
                            if app.show_exit_confirmation {
                                return Ok(());
                            }
                        }
                        KeyCode::Char('n') | KeyCode::Char('N') => {
                            if app.show_exit_confirmation {
                                app.hide_exit_confirmation();
                            }
                        }
                        KeyCode::Enter | KeyCode::Right => {
                            if !app.show_exit_confirmation {
                                app.next_step();
                            }
                        }
                        KeyCode::Left => {
                            if !app.show_exit_confirmation {
                                app.previous_step();
                            }
                        }
                        KeyCode::Up => {
                            if !app.show_exit_confirmation {
                                app.scroll_explanation_up();
                            }
                        }
                        KeyCode::Down => {
                            if !app.show_exit_confirmation {
                                app.scroll_explanation_down();
                            }
                        }
                        KeyCode::Char('c') | KeyCode::Char('C') => {
                            if !app.show_exit_confirmation {
                                app.toggle_combat_details();
                            }
                        }
                        KeyCode::Char(' ') => {
                            if !app.show_exit_confirmation {
                                app.next_animation_frame();
                            }
                        }
                        KeyCode::Char('a') | KeyCode::Char('A') => {
                            app.toggle_about();
                        }
                        _ => {}
                    }
                }
            }
        }

        if app.should_quit {
            break;
        }
    }

    Ok(())
}

fn draw_tutorial_ui(f: &mut Frame, app: &TutorialApp) {
    if app.show_about {
        // Show About section full screen
        draw_about_section(f, f.area(), app);
        return;
    }

    if app.show_exit_confirmation {
        // Show exit confirmation dialog
        draw_exit_confirmation_dialog(f, f.area());
        return;
    }

    let main_constraints = if app.match_state.show_combat_details {
        vec![
            Constraint::Length(3),  // Header
            Constraint::Length(3),  // Progress
            Constraint::Length(8),  // Match State
            Constraint::Length(15), // Combat Details
            Constraint::Min(8),     // Explanation (smaller)
            Constraint::Length(3),  // Controls
        ]
    } else {
        vec![
            Constraint::Length(3),  // Header
            Constraint::Length(3),  // Progress
            Constraint::Length(8),  // Match State
            Constraint::Min(10),    // Explanation
            Constraint::Length(3),  // Controls
        ]
    };

    let chunks = Layout::default()
        .direction(Direction::Vertical)
        .constraints(main_constraints)
        .split(f.area());

    // Header
    draw_header(f, chunks[0], app);
    
    // Progress bar
    draw_progress(f, chunks[1], app);
    
    // Match state HUD
    draw_match_state(f, chunks[2], app);
    
    if app.match_state.show_combat_details {
        // Combat details
        draw_combat_details(f, chunks[3], app);
        
        // Detailed explanation (smaller)
        draw_explanation(f, chunks[4], app);
        
        // Controls
        draw_controls(f, chunks[5], app);
    } else {
        // Detailed explanation
        draw_explanation(f, chunks[3], app);
        
        // Controls
        draw_controls(f, chunks[4], app);
    }
}

fn draw_header(f: &mut Frame, area: Rect, app: &TutorialApp) {
    let current_phase = app.current_phase();
    let current_step = app.current_step();
    
    // Use step-specific actor if available, otherwise use phase actor
    let actor = current_step.actor.as_ref().unwrap_or(&current_phase.actor);
    
    let header_text = format!(
        "{} {} - {} | Actor: {} {}",
        actor.icon(),
        current_phase.title,
        "Zero-Coordination Gaming Tutorial",
        actor.icon(),
        actor.name()
    );
    
    let header = Paragraph::new(header_text)
        .style(Style::default().fg(actor.color()).add_modifier(Modifier::BOLD))
        .block(
            Block::default()
                .borders(Borders::ALL)
                .title("ðŸŽ® Manastr Tutorial Mode")
                .title_alignment(Alignment::Center),
        )
        .alignment(Alignment::Center);
    
    f.render_widget(header, area);
}

fn draw_progress(f: &mut Frame, area: Rect, app: &TutorialApp) {
    let progress = app.progress_percentage();
    let label = format!("Phase {}/{} | Step {}/{} | {}% Complete", 
        app.current_phase + 1, 
        app.phases.len(),
        app.current_step + 1,
        app.current_phase().steps.len(),
        progress
    );
    
    let gauge = Gauge::default()
        .block(Block::default().borders(Borders::ALL).title("Progress"))
        .gauge_style(Style::default().fg(Color::Green))
        .percent(progress)
        .label(label);
    
    f.render_widget(gauge, area);
}

fn draw_match_state(f: &mut Frame, area: Rect, app: &TutorialApp) {
    let state = &app.match_state;
    
    let mut state_items = vec![
        ListItem::new(format!("â€¢ Challenge ID: {}", state.challenge_id)),
        ListItem::new(format!("â€¢ Total Mana: {} tokens", state.total_mana)),
        ListItem::new(format!("â€¢ Combat Round: {}/3", state.combat_round)),
        ListItem::new(format!("â€¢ Units Alive: Alice({}) Bob({})", state.alice_units, state.bob_units)),
        ListItem::new(format!("â€¢ Current Actor: {} {}", state.current_actor.icon(), state.current_actor.name())),
    ];

    // Add C value display if available
    if let Some(alice_c) = &state.alice_c_value {
        let alice_c_hex = hex::encode(&alice_c[..8]); // Show first 8 bytes
        state_items.push(ListItem::new(format!("â€¢ Alice C Value: {}...", alice_c_hex)));
    }
    if let Some(bob_c) = &state.bob_c_value {
        let bob_c_hex = hex::encode(&bob_c[..8]); // Show first 8 bytes  
        state_items.push(ListItem::new(format!("â€¢ Bob C Value: {}...", bob_c_hex)));
    }
    
    let list = List::new(state_items)
        .block(
            Block::default()
                .borders(Borders::ALL)
                .title("ðŸ“Š Match State HUD")
                .title_alignment(Alignment::Left),
        )
        .style(Style::default().fg(Color::White));
    
    f.render_widget(list, area);
}

fn draw_explanation(f: &mut Frame, area: Rect, app: &TutorialApp) {
    let step = app.current_step();
    
    let mut explanation_text = vec![
        Line::from(vec![
            Span::styled("ðŸ“‹ Current Action: ", Style::default().fg(Color::Yellow).add_modifier(Modifier::BOLD)),
            Span::raw(&step.action),
        ]),
        Line::from(""),
        Line::from(vec![
            Span::styled("ðŸ“– Detailed Explanation:", Style::default().fg(Color::Cyan).add_modifier(Modifier::BOLD)),
        ]),
        Line::from(""),
    ];
    
    // Add wrapped explanation text
    let explanation_lines: Vec<Line> = step.explanation
        .split('\n')
        .map(|line| Line::from(line.to_string()))
        .collect();
    explanation_text.extend(explanation_lines);
    
    // Add technical notes
    if !step.technical_notes.is_empty() {
        explanation_text.push(Line::from(""));
        explanation_text.push(Line::from(vec![
            Span::styled("ðŸ”§ Technical Details:", Style::default().fg(Color::Magenta).add_modifier(Modifier::BOLD)),
        ]));
        for note in &step.technical_notes {
            explanation_text.push(Line::from(format!("  â€¢ {}", note)));
        }
    }
    
    let explanation = Paragraph::new(explanation_text)
        .block(
            Block::default()
                .borders(Borders::ALL)
                .title("ðŸ“‹ Step-by-Step Explanation")
                .title_alignment(Alignment::Left),
        )
        .wrap(Wrap { trim: true })
        .scroll((app.explanation_scroll, 0));
    
    f.render_widget(explanation, area);
}

fn draw_combat_details(f: &mut Frame, area: Rect, app: &TutorialApp) {
    let chunks = Layout::default()
        .direction(Direction::Horizontal)
        .constraints([
            Constraint::Percentage(50), // Armies
            Constraint::Percentage(50), // Combat Results
        ])
        .split(area);

    // Draw armies
    draw_armies(f, chunks[0], app);
    
    // Draw combat results
    draw_combat_results(f, chunks[1], app);
}

fn draw_armies(f: &mut Frame, area: Rect, app: &TutorialApp) {
    if let (Some(alice_army), Some(bob_army)) = (&app.match_state.alice_army, &app.match_state.bob_army) {
        let mut army_text = vec![
            Line::from(vec![
                Span::styled("ðŸ‘¤ Alice's Army:", Style::default().fg(Color::Rgb(139, 69, 255)).add_modifier(Modifier::BOLD)),
            ]),
        ];
        
        for (i, unit) in alice_army.iter().enumerate() {
            let animation_char = match app.match_state.animation_frame {
                0 => "âš”ï¸",
                1 => "ðŸ›¡ï¸", 
                2 => "ðŸ’",
                _ => "â­",
            };
            army_text.push(Line::from(format!(
                " {} Unit {}: â¤ï¸{}  âš”ï¸{}  ðŸ›¡ï¸{}  {}",
                animation_char, i+1, unit.health, unit.attack, unit.defense,
                match unit.ability {
                    shared_game_logic::game_state::Ability::Boost => "ðŸ”¥Boost",
                    shared_game_logic::game_state::Ability::Shield => "ðŸ›¡ï¸Shield", 
                    shared_game_logic::game_state::Ability::Heal => "ðŸ’šHeal",
                    _ => "ðŸ”˜None",
                }
            )));
        }
        
        army_text.push(Line::from(""));
        army_text.push(Line::from(vec![
            Span::styled("ðŸ‘¤ Bob's Army:", Style::default().fg(Color::Rgb(139, 69, 255)).add_modifier(Modifier::BOLD)),
        ]));
        
        for (i, unit) in bob_army.iter().enumerate() {
            let animation_char = match app.match_state.animation_frame {
                0 => "âš”ï¸",
                1 => "ðŸ›¡ï¸",
                2 => "ðŸ’", 
                _ => "â­",
            };
            army_text.push(Line::from(format!(
                " {} Unit {}: â¤ï¸{}  âš”ï¸{}  ðŸ›¡ï¸{}  {}",
                animation_char, i+1, unit.health, unit.attack, unit.defense,
                match unit.ability {
                    shared_game_logic::game_state::Ability::Boost => "ðŸ”¥Boost",
                    shared_game_logic::game_state::Ability::Shield => "ðŸ›¡ï¸Shield",
                    shared_game_logic::game_state::Ability::Heal => "ðŸ’šHeal", 
                    _ => "ðŸ”˜None",
                }
            )));
        }
        
        let armies = Paragraph::new(army_text)
            .block(
                Block::default()
                    .borders(Borders::ALL)
                    .title("ðŸ›ï¸ Generated Armies from C Values")
                    .title_alignment(Alignment::Left),
            )
            .wrap(Wrap { trim: true });
        
        f.render_widget(armies, area);
    }
}

fn draw_combat_results(f: &mut Frame, area: Rect, app: &TutorialApp) {
    if !app.match_state.combat_results.is_empty() {
        let mut result_text = vec![
            Line::from(vec![
                Span::styled("âš”ï¸ Combat Results:", Style::default().fg(Color::Yellow).add_modifier(Modifier::BOLD)),
            ]),
            Line::from(""),
        ];
        
        for result in &app.match_state.combat_results {
            let winner_icon = match &result.winner {
                Some(winner) if winner == "alice" => "ðŸ‘¤ðŸ†",
                Some(winner) if winner == "bob" => "ðŸ‘¤ðŸ†", 
                _ => "ðŸ¤",
            };
            
            result_text.push(Line::from(vec![
                Span::styled(format!("Round {}: ", result.round), Style::default().fg(Color::Cyan).add_modifier(Modifier::BOLD)),
                Span::raw(winner_icon),
            ]));
            
            result_text.push(Line::from(format!(
                " Alice: {}â¤ï¸â†’{}â¤ï¸ ({}ðŸ’¥)", 
                result.alice_health_before, 
                result.alice_unit.health,
                result.bob_damage_dealt
            )));
            
            result_text.push(Line::from(format!(
                " Bob:   {}â¤ï¸â†’{}â¤ï¸ ({}ðŸ’¥)",
                result.bob_health_before,
                result.bob_unit.health, 
                result.alice_damage_dealt
            )));
            
            if let Some(ref winner) = result.winner {
                result_text.push(Line::from(vec![
                    Span::styled(format!(" Winner: {}", winner), Style::default().fg(Color::Green).add_modifier(Modifier::BOLD)),
                ]));
            } else {
                result_text.push(Line::from(vec![
                    Span::styled(" Result: Tie", Style::default().fg(Color::Yellow)),
                ]));
            }
            result_text.push(Line::from(""));
        }
        
        let results = Paragraph::new(result_text)
            .block(
                Block::default()
                    .borders(Borders::ALL)
                    .title("âš¡ Deterministic Combat Execution")
                    .title_alignment(Alignment::Left),
            )
            .wrap(Wrap { trim: true });
        
        f.render_widget(results, area);
    }
}

fn draw_about_section(f: &mut Frame, area: Rect, app: &TutorialApp) {
    let chunks = Layout::default()
        .direction(Direction::Vertical)
        .constraints([
            Constraint::Length(3),  // Header
            Constraint::Min(10),    // About Content
            Constraint::Length(3),  // Controls
        ])
        .split(area);

    // About Header
    let header = Paragraph::new("ðŸ›ï¸ ABOUT: Revolutionary Zero-Coordination Gaming Tutorial")
        .style(Style::default().fg(Color::Rgb(139, 69, 255)).add_modifier(Modifier::BOLD))
        .block(
            Block::default()
                .borders(Borders::ALL)
                .title("About Manastr Tutorial")
                .title_alignment(Alignment::Center),
        )
        .alignment(Alignment::Center);
    f.render_widget(header, chunks[0]);

    // About Content
    let about_text = vec![
        Line::from(vec![
            Span::styled("ðŸš€ REVOLUTIONARY ARCHITECTURE - NO SIMULATION!", Style::default().fg(Color::Yellow).add_modifier(Modifier::BOLD)),
        ]),
        Line::from(""),
        Line::from("This tutorial demonstrates the world's first truly decentralized multiplayer"),
        Line::from("gaming architecture. Everything you see uses REAL production services:"),
        Line::from(""),
        Line::from(vec![
            Span::styled("ðŸ”— REAL SERVICES RUNNING LOCALLY:", Style::default().fg(Color::Cyan).add_modifier(Modifier::BOLD)),
        ]),
        Line::from("  â€¢ CDK Cashu Mint (127.0.0.1:3333) - Actual token operations"),
        Line::from("  â€¢ Game Engine Bot (127.0.0.1:4444) - Pure validation authority"),
        Line::from("  â€¢ Nostr Relay (127.0.0.1:7777) - Decentralized communication"),
        Line::from(""),
        Line::from(vec![
            Span::styled("ðŸ›ï¸ PRODUCTION-IDENTICAL CODE PATHS:", Style::default().fg(Color::Green).add_modifier(Modifier::BOLD)),
        ]),
        Line::from("  âœ… Real GamingWallet instances connected to local mint"),
        Line::from("  âœ… Actual C values from mint cryptographic signatures"),
        Line::from("  âœ… Real army generation using shared-game-logic"),
        Line::from("  âœ… Authentic combat execution with deterministic outcomes"),
        Line::from("  âœ… True commitment/reveal anti-cheat system"),
        Line::from(""),
        Line::from(vec![
            Span::styled("ðŸŽ¯ DETERMINISM THROUGH SEEDING:", Style::default().fg(Color::Magenta).add_modifier(Modifier::BOLD)),
        ]),
        Line::from("  â€¢ Player keys: Seeded for consistent tutorial experience"),
        Line::from("  â€¢ Mint keys: Deterministic setup ensures predictable C values"),
        Line::from("  â€¢ Combat outcomes: Mathematical certainty, no randomness"),
        Line::from("  â€¢ Tutorial flow: Repeatable educational experience"),
        Line::from(""),
        Line::from(vec![
            Span::styled("âš”ï¸ ZERO-COORDINATION GAMING PRINCIPLES:", Style::default().fg(Color::Red).add_modifier(Modifier::BOLD)),
        ]),
        Line::from("  ðŸ”’ Players control entire match flow via cryptographic proofs"),
        Line::from("  ðŸŽ® Game Engine cannot cheat - only validates outcomes"),
        Line::from("  ðŸ“¡ Complete decentralization via Nostr events"),
        Line::from("  ðŸ’° 95% player rewards, 5% system fee (transparent economics)"),
        Line::from("  ðŸ›¡ï¸ Mathematics prevents cheating better than trusted servers"),
        Line::from(""),
        Line::from(vec![
            Span::styled("ðŸŽ® INTERACTIVE FEATURES:", Style::default().fg(Color::Blue).add_modifier(Modifier::BOLD)),
        ]),
        Line::from("  [C] Toggle combat visualization with real unit stats"),
        Line::from("  [SPACE] Animate unit icons during combat simulation"),
        Line::from("  [A] Toggle this About section"),
        Line::from(""),
        Line::from(vec![
            Span::styled("âœ¨ THE REVOLUTION:", Style::default().fg(Color::Yellow).add_modifier(Modifier::BOLD)),
        ]),
        Line::from("This isn't just a tutorial - it's proof that trustless multiplayer"),
        Line::from("gaming works TODAY. No more trusting game servers. No more single"),
        Line::from("points of failure. Just pure mathematical certainty."),
        Line::from(""),
        Line::from(vec![
            Span::styled("Welcome to the future of gaming! ðŸŽ®âš”ï¸âœ¨", Style::default().fg(Color::Green).add_modifier(Modifier::BOLD)),
        ]),
    ];

    let about_content = Paragraph::new(about_text)
        .block(
            Block::default()
                .borders(Borders::ALL)
                .title("Revolutionary Architecture Details")
                .title_alignment(Alignment::Left),
        )
        .wrap(Wrap { trim: true })
        .scroll((app.explanation_scroll, 0));
    
    f.render_widget(about_content, chunks[1]);

    // About Controls
    let controls_text = "ðŸŽ¯ [A] Close About | [â†‘â†“] Scroll | [Q/ESC] Quit Tutorial";
    let controls = Paragraph::new(controls_text)
        .style(Style::default().fg(Color::Green))
        .block(
            Block::default()
                .borders(Borders::ALL)
                .title("Controls")
                .title_alignment(Alignment::Center),
        )
        .alignment(Alignment::Center);
    
    f.render_widget(controls, chunks[2]);
}

fn draw_exit_confirmation_dialog(f: &mut Frame, area: Rect) {
    // Center the dialog
    let popup_area = Layout::default()
        .direction(Direction::Vertical)
        .constraints([
            Constraint::Percentage(30),
            Constraint::Length(10),
            Constraint::Percentage(30),
        ])
        .split(area)[1];
    
    let popup_area = Layout::default()
        .direction(Direction::Horizontal)
        .constraints([
            Constraint::Percentage(25),
            Constraint::Percentage(50),
            Constraint::Percentage(25),
        ])
        .split(popup_area)[1];

    // Clear background
    let clear = Block::default().style(Style::default().bg(Color::Black));
    f.render_widget(clear, area);

    let confirmation_text = vec![
        Line::from(""),
        Line::from(vec![
            Span::styled("ðŸ¤” Exit Tutorial?", Style::default().fg(Color::Yellow).add_modifier(Modifier::BOLD)),
        ]),
        Line::from(""),
        Line::from("Are you sure you want to exit the"),
        Line::from("zero-coordination gaming tutorial?"),
        Line::from(""),
        Line::from(vec![
            Span::styled("[Y] Yes, Exit", Style::default().fg(Color::Red).add_modifier(Modifier::BOLD)),
            Span::raw("    "),
            Span::styled("[N] No, Continue", Style::default().fg(Color::Green).add_modifier(Modifier::BOLD)),
        ]),
        Line::from(""),
    ];

    let confirmation_dialog = Paragraph::new(confirmation_text)
        .block(
            Block::default()
                .borders(Borders::ALL)
                .title("Confirm Exit")
                .title_alignment(Alignment::Center)
                .border_style(Style::default().fg(Color::Red)),
        )
        .alignment(Alignment::Center);
    
    f.render_widget(confirmation_dialog, popup_area);
}

fn draw_controls(f: &mut Frame, area: Rect, app: &TutorialApp) {
    let controls_text = if app.is_final_step() {
        "ðŸŽ¯ [A] About | [C] Combat | [SPACE] Animate | [Q/ESC] Quit Tutorial"
    } else if app.match_state.show_combat_details {
        "ðŸŽ¯ [A] About | [C] Hide Combat | [SPACE] Animate | [ENTER/â†’] Next | [â†] Previous | [â†‘â†“] Scroll | [Q/ESC] Quit"
    } else {
        "ðŸŽ¯ [A] About | [C] Show Combat | [ENTER/â†’] Next Step | [â†] Previous Step | [â†‘â†“] Scroll | [Q/ESC] Quit"
    };
    
    let controls = Paragraph::new(controls_text)
        .style(Style::default().fg(Color::Green))
        .block(
            Block::default()
                .borders(Borders::ALL)
                .title("Controls")
                .title_alignment(Alignment::Center),
        )
        .alignment(Alignment::Center);
    
    f.render_widget(controls, area);
}