use anyhow::Result;
use crossterm::{
    event::{self, DisableMouseCapture, EnableMouseCapture, Event, KeyCode, KeyEventKind},
    execute,
    terminal::{disable_raw_mode, enable_raw_mode, EnterAlternateScreen, LeaveAlternateScreen},
};
use ratatui::{
    backend::CrosstermBackend,
    layout::{Alignment, Constraint, Direction, Layout, Rect},
    style::{Color, Modifier, Style},
    text::{Line, Span},
    widgets::{
        Block, Borders, Gauge, List, ListItem, Paragraph, Wrap,
    },
    Frame, Terminal,
};
use std::io;
use tokio::time::Duration;

/// Tutorial application state
#[derive(Clone)]
pub struct TutorialApp {
    current_phase: usize,
    current_step: usize,
    phases: Vec<TutorialPhase>,
    match_state: MatchState,
    should_quit: bool,
    explanation_scroll: u16,
    explanation_height: u16,
}

/// Individual tutorial phase
#[derive(Clone)]
pub struct TutorialPhase {
    title: String,
    actor: Actor,
    steps: Vec<TutorialStep>,
}

/// Individual step within a phase
#[derive(Clone)]
pub struct TutorialStep {
    description: String,
    explanation: String,
    action: String,
    technical_notes: Vec<String>,
}

/// Current match state for HUD display
#[derive(Clone)]
pub struct MatchState {
    challenge_id: String,
    total_stake: u32,
    combat_round: u32,
    alice_units: u32,
    bob_units: u32,
    current_actor: Actor,
}

/// Actor in the tutorial flow
#[derive(Clone, PartialEq)]
pub enum Actor {
    Alice,
    Bob,
    GameEngine,
    NostrRelay,
    CashuMint,
}

impl Actor {
    fn icon(&self) -> &str {
        match self {
            Actor::Alice => "üë§",
            Actor::Bob => "üë§",
            Actor::GameEngine => "üéÆ",
            Actor::NostrRelay => "üì°",
            Actor::CashuMint => "üè¶",
        }
    }

    fn name(&self) -> &str {
        match self {
            Actor::Alice => "Alice",
            Actor::Bob => "Bob", 
            Actor::GameEngine => "Game Engine",
            Actor::NostrRelay => "Nostr Relay",
            Actor::CashuMint => "Cashu Mint",
        }
    }

    fn color(&self) -> Color {
        match self {
            Actor::Alice | Actor::Bob => Color::Rgb(139, 69, 255), // Purple for players
            Actor::NostrRelay => Color::Blue,                       // Blue for comms
            Actor::GameEngine | Actor::CashuMint => Color::Rgb(255, 153, 0), // Orange for authority
        }
    }
}

impl Default for MatchState {
    fn default() -> Self {
        Self {
            challenge_id: "abc123...".to_string(),
            total_stake: 200,
            combat_round: 1,
            alice_units: 4,
            bob_units: 4,
            current_actor: Actor::Alice,
        }
    }
}

impl TutorialApp {
    pub fn new() -> Self {
        let phases = vec![
            TutorialPhase {
                title: "üöÄ PHASE 0: Acquire Mana".to_string(),
                actor: Actor::Alice,
                steps: vec![
                    TutorialStep {
                        description: "Alice requests mana tokens from Game Engine's CDK mint".to_string(),
                        explanation: "In Manastr's revolutionary architecture, players acquire mana tokens from the Game Engine's Cashu mint. These tokens contain cryptographic randomness (C values) that players cannot manipulate, ensuring fair army generation.".to_string(),
                        action: "üè¶ Requesting mana tokens with C values...".to_string(),
                        technical_notes: vec![
                            "C values are generated by mint's blinding process".to_string(),
                            "Neither mint nor player can bias this randomness".to_string(),
                            "Deterministic testing uses controlled mint keys".to_string(),
                        ],
                    },
                    TutorialStep {
                        description: "Alice unblinds mana to resolve C value paired with her x value".to_string(),
                        explanation: "The unblinding process reveals the C value - a 32-byte cryptographic proof that will be used to generate Alice's army. This value is authoritative randomness that neither the mint nor Alice could have predetermined.".to_string(),
                        action: "üîì Unblinding mana token to extract C value...".to_string(),
                        technical_notes: vec![
                            "C = mint_signature * mint_pubkey (simplified)".to_string(),
                            "x is Alice's chosen blind factor".to_string(),
                            "Unblinding: proof = C * x^-1".to_string(),
                        ],
                    },
                ],
            },
            TutorialPhase {
                title: "üöÄ PHASE 1: Pick an Army".to_string(),
                actor: Actor::Alice,
                steps: vec![
                    TutorialStep {
                        description: "Alice generates her army from the Cashu C values".to_string(),
                        explanation: "The 32 bytes of the C value are decoded into army units using shared game logic. This is like drawing cards from a cryptographically shuffled deck - Alice now knows her units but no one else does. Different keysets could enable complex meta-protocols like MTG-style gameplay.".to_string(),
                        action: "‚öîÔ∏è Generating army from C value randomness...".to_string(),
                        technical_notes: vec![
                            "32 bytes ‚Üí 4 unit seeds (8 bytes each)".to_string(),
                            "Unit stats: HP, Attack, Defense, Speed".to_string(),
                            "Theming abstracted: Knights? Ninjas? Space Marines?".to_string(),
                        ],
                    },
                    TutorialStep {
                        description: "Alice creates SHA256 commitment of her army composition".to_string(),
                        explanation: "Alice commits to her army using a cryptographic hash. This commitment prevents her from changing her army later while keeping it secret from Bob. This is the foundation of the anti-cheat system - mathematical certainty instead of trust.".to_string(),
                        action: "üîê Creating SHA256 commitment of army...".to_string(),
                        technical_notes: vec![
                            "commit = SHA256(army_units + nonce)".to_string(),
                            "Prevents army manipulation after seeing opponent".to_string(),
                            "Commitment/reveal scheme ensures fair play".to_string(),
                        ],
                    },
                    TutorialStep {
                        description: "Alice publishes KIND 31000 Match Challenge to Nostr".to_string(),
                        explanation: "Alice broadcasts her challenge to the decentralized Nostr network. This event contains her army commitment, stake amount, and challenge terms. The beauty of Nostr is that this can be created offline and published later - perfect for asynchronous gaming.".to_string(),
                        action: "üì° Publishing KIND 31000 Match Challenge event...".to_string(),
                        technical_notes: vec![
                            "Event includes: army_commitment, stake, terms".to_string(),
                            "Cryptographically signed by Alice's key".to_string(),
                            "Can be created offline, published later".to_string(),
                        ],
                    },
                ],
            },
            TutorialPhase {
                title: "üåÄ Temporal Suspension".to_string(),
                actor: Actor::GameEngine,
                steps: vec![
                    TutorialStep {
                        description: "Game Engine reads KIND 31000 Match Challenge from Nostr relay".to_string(),
                        explanation: "Due to Nostr's asynchronous nature, the Game Engine can process events at its own pace. Players don't need to be online simultaneously - the cryptographic commitments maintain the chain of trust even with temporal gaps.".to_string(),
                        action: "üéÆ Processing challenge event asynchronously...".to_string(),
                        technical_notes: vec![
                            "Events can be stored and processed offline".to_string(),
                            "Commitment chain maintains order integrity".to_string(),
                            "P2P communication works without real-time sync".to_string(),
                        ],
                    },
                    TutorialStep {
                        description: "Game Engine validates challenge format and updates state to CHALLENGED".to_string(),
                        explanation: "The Game Engine acts as a pure validator, verifying the challenge format and signature. It updates its internal state machine but cannot manipulate the game outcome - it only validates what players have committed to cryptographically.".to_string(),
                        action: "‚úÖ Validating challenge and updating state machine...".to_string(),
                        technical_notes: vec![
                            "Validates: signature, format, stake amount".to_string(),
                            "State transition: NONE ‚Üí CHALLENGED".to_string(),
                            "Engine cannot manipulate player commitments".to_string(),
                        ],
                    },
                ],
            },
            TutorialPhase {
                title: "‚öîÔ∏è PHASE 2: Pick a Fight".to_string(),
                actor: Actor::Bob,
                steps: vec![
                    TutorialStep {
                        description: "Bob requests mana tokens and unblinds to get his C values".to_string(),
                        explanation: "Bob follows the same process as Alice - acquiring mana tokens from the Game Engine's mint and unblinding them to reveal his unique C values. Each player gets their own cryptographically random army composition.".to_string(),
                        action: "üè¶ Bob acquiring mana and extracting C values...".to_string(),
                        technical_notes: vec![
                            "Same mint process as Alice".to_string(),
                            "Independent C values for Bob".to_string(),
                            "Deterministic for testing, random in production".to_string(),
                        ],
                    },
                    TutorialStep {
                        description: "Bob generates his army and creates commitment".to_string(),
                        explanation: "Bob's army is generated from his unique C values using the same shared game logic as Alice. He then creates his own SHA256 commitment. Both players now have committed to their armies without revealing them.".to_string(),
                        action: "‚öîÔ∏è Bob generating army and creating commitment...".to_string(),
                        technical_notes: vec![
                            "Uses same army generation algorithm".to_string(),
                            "Independent commitment: SHA256(bob_army + nonce)".to_string(),
                            "Both armies now committed but secret".to_string(),
                        ],
                    },
                    TutorialStep {
                        description: "Bob publishes KIND 31001 Match Acceptance to Nostr".to_string(),
                        explanation: "Bob accepts Alice's challenge by publishing his own Nostr event. This contains his army commitment and confirms his stake. The match is now officially accepted and both players have committed armies.".to_string(),
                        action: "üì° Publishing KIND 31001 Match Acceptance...".to_string(),
                        technical_notes: vec![
                            "References Alice's challenge event ID".to_string(),
                            "Contains Bob's army commitment".to_string(),
                            "Confirms stake matching Alice's terms".to_string(),
                        ],
                    },
                ],
            },
            TutorialPhase {
                title: "üåÄ Temporal Suspension Complete".to_string(),
                actor: Actor::GameEngine,
                steps: vec![
                    TutorialStep {
                        description: "Game Engine processes Bob's acceptance and updates state to ACCEPTED".to_string(),
                        explanation: "The Game Engine validates Bob's acceptance event, verifies his commitment format, and updates the match state. Both players have now committed to their armies cryptographically - the match is officially underway.".to_string(),
                        action: "‚úÖ Processing acceptance and updating match state...".to_string(),
                        technical_notes: vec![
                            "Validates Bob's signature and commitment format".to_string(),
                            "State transition: CHALLENGED ‚Üí ACCEPTED".to_string(),
                            "Both army commitments now locked in".to_string(),
                        ],
                    },
                ],
            },
            TutorialPhase {
                title: "üîì PHASE 3: Token Revelation".to_string(),
                actor: Actor::Alice,
                steps: vec![
                    TutorialStep {
                        description: "Alice reveals her actual Cashu tokens via KIND 31002".to_string(),
                        explanation: "Now Alice must reveal her actual Cashu tokens that were used to generate her army. This allows the Game Engine to verify that her army commitment was generated honestly from real C values, not fabricated.".to_string(),
                        action: "üé´ Publishing KIND 31002 Token Reveal...".to_string(),
                        technical_notes: vec![
                            "Reveals: token proofs, C values, x values".to_string(),
                            "Allows army verification without revealing units".to_string(),
                            "Prevents fake army commitments".to_string(),
                        ],
                    },
                    TutorialStep {
                        description: "Bob reveals his actual Cashu tokens via KIND 31002".to_string(),
                        explanation: "Bob follows the same process, revealing his Cashu tokens. Both players have now provided the cryptographic proofs needed for the Game Engine to verify their armies were generated fairly.".to_string(),
                        action: "üé´ Bob publishing KIND 31002 Token Reveal...".to_string(),
                        technical_notes: vec![
                            "Bob's token revelation follows same format".to_string(),
                            "Both players now have verifiable armies".to_string(),
                            "Game Engine can re-generate armies to check".to_string(),
                        ],
                    },
                    TutorialStep {
                        description: "Game Engine verifies tokens and re-generates armies".to_string(),
                        explanation: "The Game Engine queries the Cashu mint to verify both players' tokens are valid and unspent, then re-generates their armies from the revealed C values. It verifies these match the original commitments - catching any cheating attempts.".to_string(),
                        action: "üîç Verifying tokens and army commitments...".to_string(),
                        technical_notes: vec![
                            "Queries mint: are tokens valid and unspent?".to_string(),
                            "Re-generates armies from C values".to_string(),
                            "Verifies: generated_army_hash == commitment".to_string(),
                        ],
                    },
                    TutorialStep {
                        description: "Match state updated to IN_COMBAT - battle begins!".to_string(),
                        explanation: "With both armies verified as legitimate, the Game Engine updates the match state to IN_COMBAT. The cryptographic foundations are complete - now the tactical battle can begin with mathematical certainty of fairness.".to_string(),
                        action: "‚öîÔ∏è Transitioning to combat phase...".to_string(),
                        technical_notes: vec![
                            "State transition: ACCEPTED ‚Üí IN_COMBAT".to_string(),
                            "Both armies verified and ready".to_string(),
                            "Combat can proceed with anti-cheat guarantees".to_string(),
                        ],
                    },
                ],
            },
            TutorialPhase {
                title: "‚öîÔ∏è PHASE 4-6: Combat Rounds".to_string(),
                actor: Actor::Alice,
                steps: vec![
                    TutorialStep {
                        description: "Alice (challenger) commits to her moves for Round 1".to_string(),
                        explanation: "Combat uses the same commitment/reveal pattern. Alice chooses tactical moves for each of her units and commits to them with SHA256. This prevents her from changing moves after seeing Bob's commitment - ensuring fair tactical play.".to_string(),
                        action: "üé≤ Creating SHA256 commitment of combat moves...".to_string(),
                        technical_notes: vec![
                            "Challenger (Alice) always moves first".to_string(),
                            "move_commit = SHA256(unit_moves + nonce)".to_string(),
                            "Prevents move manipulation after seeing opponent".to_string(),
                        ],
                    },
                    TutorialStep {
                        description: "Bob sees Alice's commitment and commits to his counter-moves".to_string(),
                        explanation: "Bob receives Alice's move commitment and must commit to his own moves. He can see that Alice has committed to something, but not what those moves are. This creates a simultaneous-play effect even in an asynchronous system.".to_string(),
                        action: "üéØ Bob committing to counter-moves...".to_string(),
                        technical_notes: vec![
                            "Bob's commitment may reference Alice's commitment".to_string(),
                            "Creates simultaneous play in async environment".to_string(),
                            "Both players locked into their tactical decisions".to_string(),
                        ],
                    },
                    TutorialStep {
                        description: "Both players reveal moves - Game Engine executes combat".to_string(),
                        explanation: "With both players committed, they reveal their actual moves. The Game Engine verifies the moves match the commitments (anti-cheat) then executes the combat round using shared WASM logic. This process repeats for each combat round.".to_string(),
                        action: "‚ö° Executing combat round with shared game logic...".to_string(),
                        technical_notes: vec![
                            "Verifies: revealed_moves_hash == commitment".to_string(),
                            "Uses shared WASM for identical client/server logic".to_string(),
                            "Updates unit health, positions, status".to_string(),
                        ],
                    },
                ],
            },
            TutorialPhase {
                title: "üèÜ PHASE 7: Match Result Submission".to_string(),
                actor: Actor::Alice,
                steps: vec![
                    TutorialStep {
                        description: "Alice calculates final match outcome locally".to_string(),
                        explanation: "After all combat rounds, Alice uses the shared game logic to calculate the final match state locally. She determines the winner, final unit states, and overall outcome. This calculation should match what the Game Engine will compute.".to_string(),
                        action: "üìä Calculating final match outcome...".to_string(),
                        technical_notes: vec![
                            "Uses same shared logic as Game Engine".to_string(),
                            "Calculates: winner, final HP, casualties".to_string(),
                            "Local calculation should match server".to_string(),
                        ],
                    },
                    TutorialStep {
                        description: "Alice publishes KIND 31005 Match Result".to_string(),
                        explanation: "Alice publishes her calculated match result to Nostr. This includes the winner determination and final game state. Her signature proves she agrees to this outcome - critical for the validation phase.".to_string(),
                        action: "üì° Publishing KIND 31005 with match outcome...".to_string(),
                        technical_notes: vec![
                            "Contains: winner, final_state, signature".to_string(),
                            "Cryptographic agreement to outcome".to_string(),
                            "Required for Game Engine validation".to_string(),
                        ],
                    },
                    TutorialStep {
                        description: "Bob calculates and submits his match result".to_string(),
                        explanation: "Bob performs the same calculation using shared logic and must agree with Alice's result. If both players submit the same outcome, it provides strong evidence the match was played fairly. Disagreement would trigger dispute resolution.".to_string(),
                        action: "üìä Bob submitting matching result...".to_string(),
                        technical_notes: vec![
                            "Bob's calculation must match Alice's".to_string(),
                            "Both signatures required for validation".to_string(),
                            "Disagreement triggers dispute handling".to_string(),
                        ],
                    },
                ],
            },
            TutorialPhase {
                title: "‚úÖ PHASE 8: Game Engine Validation".to_string(),
                actor: Actor::GameEngine,
                steps: vec![
                    TutorialStep {
                        description: "Game Engine re-executes the entire match independently".to_string(),
                        explanation: "The Game Engine now re-plays the entire match from start to finish using the shared WASM logic. It processes all commitments and reveals, executes all combat rounds, and calculates the final outcome independently.".to_string(),
                        action: "üîç Re-executing complete match for validation...".to_string(),
                        technical_notes: vec![
                            "Uses same shared WASM logic as players".to_string(),
                            "Processes all events chronologically".to_string(),
                            "Independent calculation of final state".to_string(),
                        ],
                    },
                    TutorialStep {
                        description: "Game Engine verifies outcome matches player submissions".to_string(),
                        explanation: "The Game Engine compares its calculated outcome with what both players submitted. If everything matches, the match is validated as fair and legitimate. This proves the entire zero-coordination gaming system worked correctly.".to_string(),
                        action: "‚úÖ Verifying outcome matches player calculations...".to_string(),
                        technical_notes: vec![
                            "Compares: engine_result == player_results".to_string(),
                            "Validates entire cryptographic chain".to_string(),
                            "Proves zero-coordination gaming worked".to_string(),
                        ],
                    },
                ],
            },
            TutorialPhase {
                title: "üí∞ PHASE 9: Loot Distribution".to_string(),
                actor: Actor::GameEngine,
                steps: vec![
                    TutorialStep {
                        description: "Game Engine burns players' original mana tokens".to_string(),
                        explanation: "With the match validated, the Game Engine uses its authorized signature to burn both players' original mana tokens from the CDK mint. This prevents double-spending and officially consumes the staked tokens.".to_string(),
                        action: "üî• Burning staked mana tokens...".to_string(),
                        technical_notes: vec![
                            "Uses Game Engine's authorized mint signature".to_string(),
                            "Burns both Alice's and Bob's staked tokens".to_string(),
                            "Prevents double-spending of game tokens".to_string(),
                        ],
                    },
                    TutorialStep {
                        description: "Game Engine mints loot tokens for the winner".to_string(),
                        explanation: "The Game Engine mints new loot tokens for Alice (the winner). Following the 95%/5% economic model, Alice receives 190 tokens (95% of the 200 total stake) while 10 tokens go to system fees. These tokens are locked to Alice's npub.".to_string(),
                        action: "üéÅ Minting 190 loot tokens for Alice...".to_string(),
                        technical_notes: vec![
                            "Economic model: 95% to winner, 5% system fee".to_string(),
                            "190 tokens to Alice, 10 to system".to_string(),
                            "Tokens locked to winner's npub pubkey".to_string(),
                        ],
                    },
                    TutorialStep {
                        description: "Game Engine publishes KIND 31006 Loot Distribution".to_string(),
                        explanation: "The Game Engine publishes the final authoritative event - KIND 31006 Loot Distribution. This is the only event the Game Engine authoritatively creates, containing the official match outcome and economic distribution. Zero-coordination gaming is complete!".to_string(),
                        action: "üì° Publishing authoritative loot distribution...".to_string(),
                        technical_notes: vec![
                            "Only authoritative event from Game Engine".to_string(),
                            "Contains: winner, loot_tokens, distribution".to_string(),
                            "Completes zero-coordination gaming cycle".to_string(),
                        ],
                    },
                    TutorialStep {
                        description: "üéâ Zero-Coordination Gaming Achieved!".to_string(),
                        explanation: "Congratulations! You've witnessed the complete revolutionary architecture in action. Players controlled the entire match flow through cryptographic commitments, the Game Engine only validated outcomes, and mathematics prevented all cheating. This is the future of decentralized gaming - no trust required, just cryptographic certainty.".to_string(),
                        action: "üöÄ Revolutionary gaming paradigm complete!".to_string(),
                        technical_notes: vec![
                            "Players controlled 100% of game flow".to_string(),
                            "Game Engine provided pure validation only".to_string(),
                            "Cryptography prevented all cheating attempts".to_string(),
                            "Perfect decentralization achieved".to_string(),
                        ],
                    },
                ],
            },
        ];

        Self {
            current_phase: 0,
            current_step: 0,
            phases,
            match_state: MatchState::default(),
            should_quit: false,
            explanation_scroll: 0,
            explanation_height: 10,
        }
    }

    fn current_phase(&self) -> &TutorialPhase {
        &self.phases[self.current_phase]
    }

    fn current_step(&self) -> &TutorialStep {
        &self.current_phase().steps[self.current_step]
    }

    fn progress_percentage(&self) -> u16 {
        let total_steps: usize = self.phases.iter().map(|p| p.steps.len()).sum();
        let completed_steps: usize = self.phases[..self.current_phase]
            .iter()
            .map(|p| p.steps.len())
            .sum::<usize>() + self.current_step;
        
        ((completed_steps as f64 / total_steps as f64) * 100.0) as u16
    }

    fn next_step(&mut self) {
        if self.current_step + 1 < self.current_phase().steps.len() {
            self.current_step += 1;
        } else if self.current_phase + 1 < self.phases.len() {
            self.current_phase += 1;
            self.current_step = 0;
            // Update match state based on phase
            self.update_match_state();
        } else {
            self.should_quit = true;
        }
        self.explanation_scroll = 0;
    }

    fn previous_step(&mut self) {
        if self.current_step > 0 {
            self.current_step -= 1;
        } else if self.current_phase > 0 {
            self.current_phase -= 1;
            self.current_step = self.current_phase().steps.len() - 1;
            self.update_match_state();
        }
        self.explanation_scroll = 0;
    }

    fn update_match_state(&mut self) {
        let phase = &self.phases[self.current_phase];
        self.match_state.current_actor = phase.actor.clone();
        
        match self.current_phase {
            0 => {
                // Phase 0: Acquire Mana
                self.match_state.combat_round = 0;
                self.match_state.challenge_id = "...".to_string();
            }
            1 => {
                // Phase 1: Pick an Army
                self.match_state.challenge_id = "abc123...".to_string();
            }
            2 => {
                // Temporal Suspension
                self.match_state.challenge_id = "abc123...".to_string();
            }
            3 => {
                // Phase 2: Pick a Fight (Bob)
                self.match_state.challenge_id = "abc123...".to_string();
            }
            4 => {
                // Temporal Suspension Complete
                self.match_state.challenge_id = "abc123...".to_string();
            }
            5 => {
                // Phase 3: Token Revelation
                self.match_state.challenge_id = "abc123...".to_string();
            }
            6 => {
                // Phase 4-6: Combat Rounds
                self.match_state.combat_round = 1;
                self.match_state.alice_units = 4;
                self.match_state.bob_units = 4;
                
                // Update based on step within combat phase
                match self.current_step {
                    0 => {
                        self.match_state.combat_round = 1;
                        self.match_state.alice_units = 4;
                        self.match_state.bob_units = 4;
                    }
                    1 => {
                        self.match_state.combat_round = 2;
                        self.match_state.alice_units = 3;
                        self.match_state.bob_units = 3;
                    }
                    2 => {
                        self.match_state.combat_round = 3;
                        self.match_state.alice_units = 2;
                        self.match_state.bob_units = 1;
                    }
                    _ => {}
                }
            }
            7 => {
                // Phase 7: Match Result Submission
                self.match_state.combat_round = 3;
                self.match_state.alice_units = 1;  // Alice wins
                self.match_state.bob_units = 0;
            }
            8 => {
                // Phase 8: Game Engine Validation
                self.match_state.combat_round = 3;
                self.match_state.alice_units = 1;
                self.match_state.bob_units = 0;
            }
            9 => {
                // Phase 9: Loot Distribution
                self.match_state.combat_round = 3;
                self.match_state.alice_units = 1;
                self.match_state.bob_units = 0;
                self.match_state.total_stake = 200; // Emphasize the 190/10 split
            }
            _ => {}
        }
    }

    fn scroll_explanation_up(&mut self) {
        if self.explanation_scroll > 0 {
            self.explanation_scroll -= 1;
        }
    }

    fn scroll_explanation_down(&mut self) {
        self.explanation_scroll += 1;
    }
}

pub async fn run_interactive_tutorial() -> Result<()> {
    // Setup terminal
    enable_raw_mode()?;
    let mut stdout = io::stdout();
    execute!(stdout, EnterAlternateScreen, EnableMouseCapture)?;
    let backend = CrosstermBackend::new(stdout);
    let mut terminal = Terminal::new(backend)?;

    // Create app state
    let mut app = TutorialApp::new();

    // Run the tutorial
    let result = run_tutorial_loop(&mut terminal, &mut app).await;

    // Restore terminal
    disable_raw_mode()?;
    execute!(
        terminal.backend_mut(),
        LeaveAlternateScreen,
        DisableMouseCapture
    )?;
    terminal.show_cursor()?;

    result
}

async fn run_tutorial_loop(
    terminal: &mut Terminal<CrosstermBackend<io::Stdout>>,
    app: &mut TutorialApp,
) -> Result<()> {
    loop {
        terminal.draw(|f| draw_tutorial_ui(f, app))?;

        // Handle events
        if event::poll(Duration::from_millis(100))? {
            if let Event::Key(key) = event::read()? {
                if key.kind == KeyEventKind::Press {
                    match key.code {
                        KeyCode::Char('q') | KeyCode::Esc => {
                            app.should_quit = true;
                        }
                        KeyCode::Enter | KeyCode::Right => {
                            app.next_step();
                        }
                        KeyCode::Left => {
                            app.previous_step();
                        }
                        KeyCode::Up => {
                            app.scroll_explanation_up();
                        }
                        KeyCode::Down => {
                            app.scroll_explanation_down();
                        }
                        _ => {}
                    }
                }
            }
        }

        if app.should_quit {
            break;
        }
    }

    Ok(())
}

fn draw_tutorial_ui(f: &mut Frame, app: &TutorialApp) {
    let chunks = Layout::default()
        .direction(Direction::Vertical)
        .constraints([
            Constraint::Length(3),  // Header
            Constraint::Length(3),  // Progress
            Constraint::Length(8),  // Match State
            Constraint::Min(10),    // Explanation
            Constraint::Length(3),  // Controls
        ])
        .split(f.area());

    // Header
    draw_header(f, chunks[0], app);
    
    // Progress bar
    draw_progress(f, chunks[1], app);
    
    // Match state HUD
    draw_match_state(f, chunks[2], app);
    
    // Detailed explanation
    draw_explanation(f, chunks[3], app);
    
    // Controls
    draw_controls(f, chunks[4]);
}

fn draw_header(f: &mut Frame, area: Rect, app: &TutorialApp) {
    let current_phase = app.current_phase();
    let actor = &current_phase.actor;
    
    let header_text = format!(
        "{} {} - {} | Actor: {} {}",
        actor.icon(),
        current_phase.title,
        "Zero-Coordination Gaming Tutorial",
        actor.icon(),
        actor.name()
    );
    
    let header = Paragraph::new(header_text)
        .style(Style::default().fg(actor.color()).add_modifier(Modifier::BOLD))
        .block(
            Block::default()
                .borders(Borders::ALL)
                .title("üéÆ Manastr Tutorial Mode")
                .title_alignment(Alignment::Center),
        )
        .alignment(Alignment::Center);
    
    f.render_widget(header, area);
}

fn draw_progress(f: &mut Frame, area: Rect, app: &TutorialApp) {
    let progress = app.progress_percentage();
    let label = format!("Phase {}/{} | Step {}/{} | {}% Complete", 
        app.current_phase + 1, 
        app.phases.len(),
        app.current_step + 1,
        app.current_phase().steps.len(),
        progress
    );
    
    let gauge = Gauge::default()
        .block(Block::default().borders(Borders::ALL).title("Progress"))
        .gauge_style(Style::default().fg(Color::Green))
        .percent(progress)
        .label(label);
    
    f.render_widget(gauge, area);
}

fn draw_match_state(f: &mut Frame, area: Rect, app: &TutorialApp) {
    let state = &app.match_state;
    
    let state_items = vec![
        ListItem::new(format!("‚Ä¢ Challenge ID: {}", state.challenge_id)),
        ListItem::new(format!("‚Ä¢ Total Stake: {} mana", state.total_stake)),
        ListItem::new(format!("‚Ä¢ Combat Round: {}/3", state.combat_round)),
        ListItem::new(format!("‚Ä¢ Units Alive: Alice({}) Bob({})", state.alice_units, state.bob_units)),
        ListItem::new(format!("‚Ä¢ Current Actor: {} {}", state.current_actor.icon(), state.current_actor.name())),
    ];
    
    let list = List::new(state_items)
        .block(
            Block::default()
                .borders(Borders::ALL)
                .title("üìä Match State HUD")
                .title_alignment(Alignment::Left),
        )
        .style(Style::default().fg(Color::White));
    
    f.render_widget(list, area);
}

fn draw_explanation(f: &mut Frame, area: Rect, app: &TutorialApp) {
    let step = app.current_step();
    
    let mut explanation_text = vec![
        Line::from(vec![
            Span::styled("üìã Current Action: ", Style::default().fg(Color::Yellow).add_modifier(Modifier::BOLD)),
            Span::raw(&step.action),
        ]),
        Line::from(""),
        Line::from(vec![
            Span::styled("üìñ Detailed Explanation:", Style::default().fg(Color::Cyan).add_modifier(Modifier::BOLD)),
        ]),
        Line::from(""),
    ];
    
    // Add wrapped explanation text
    let explanation_lines: Vec<Line> = step.explanation
        .split('\n')
        .map(|line| Line::from(line.to_string()))
        .collect();
    explanation_text.extend(explanation_lines);
    
    // Add technical notes
    if !step.technical_notes.is_empty() {
        explanation_text.push(Line::from(""));
        explanation_text.push(Line::from(vec![
            Span::styled("üîß Technical Details:", Style::default().fg(Color::Magenta).add_modifier(Modifier::BOLD)),
        ]));
        for note in &step.technical_notes {
            explanation_text.push(Line::from(format!("  ‚Ä¢ {}", note)));
        }
    }
    
    let explanation = Paragraph::new(explanation_text)
        .block(
            Block::default()
                .borders(Borders::ALL)
                .title("üìã Step-by-Step Explanation")
                .title_alignment(Alignment::Left),
        )
        .wrap(Wrap { trim: true })
        .scroll((app.explanation_scroll, 0));
    
    f.render_widget(explanation, area);
}

fn draw_controls(f: &mut Frame, area: Rect) {
    let controls_text = "üéØ [ENTER/‚Üí] Next Step | [‚Üê] Previous Step | [‚Üë‚Üì] Scroll | [Q/ESC] Quit Tutorial";
    
    let controls = Paragraph::new(controls_text)
        .style(Style::default().fg(Color::Green))
        .block(
            Block::default()
                .borders(Borders::ALL)
                .title("Controls")
                .title_alignment(Alignment::Center),
        )
        .alignment(Alignment::Center);
    
    f.render_widget(controls, area);
}