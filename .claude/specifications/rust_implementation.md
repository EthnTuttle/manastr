# Rust Implementation Technical Specifications

## Technology Stack Overview

### Backend Services (Rust)
- **Web Framework:** `axum` for REST APIs and WebSocket handling
- **Database:** `sqlx` with PostgreSQL for type-safe database access  
- **Async Runtime:** `tokio` for async/await concurrency
- **Cryptography:** `secp256k1`, `sha2` crates
- **Cashu Integration:** Direct CDK implementation (dual currencies)
- **Nostr Integration:** `nostr-sdk` crate for protocol implementation
- **Serialization:** `serde` with JSON for data formats

### WASM Shared Logic (Rust → WebAssembly)
- **Combat Engine:** `wasm-pack` for WebAssembly compilation
- **Unit Generation:** Shared deterministic logic between client/server
- **Game State:** Common data structures compiled to WASM
- **Client Bindings:** TypeScript bindings generated by `wasm-bindgen`

### Frontend (Web/Mobile)
- **Web:** React with TypeScript + WASM modules
- **Mobile:** React Native with WASM bindings
- **State Management:** Zustand for lightweight state management
- **WASM Integration:** `@wasm-tool/wasm-pack-plugin` for build integration

## Rust Crate Dependencies

### Core Dependencies
```toml
[dependencies]
# Web framework and HTTP
axum = "0.7"
tokio = { version = "1.0", features = ["full"] }
tower = "0.4"
tower-http = "0.5"

# Database and persistence
sqlx = { version = "0.7", features = ["postgres", "runtime-tokio-rustls", "uuid", "chrono"] }
uuid = "1.0"
chrono = { version = "0.4", features = ["serde"] }

# Cashu CDK implementation
cdk = "0.1"  # Pure CDK implementation

# Nostr integration
nostr-sdk = "0.29"

# Basic cryptography
secp256k1 = "0.28"
sha2 = "0.10"

# Serialization and utilities
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
anyhow = "1.0"
thiserror = "1.0"
tracing = "0.1"
tracing-subscriber = "0.3"

# WASM support
wasm-bindgen = "0.2"
wasm-bindgen-futures = "0.4"
js-sys = "0.3"
web-sys = "0.3"
```

### WASM-Specific Dependencies
```toml
# For WASM compilation
[dependencies.wasm-bindgen]
version = "0.2"
features = [
  "serde-serialize",
]

# For WASM target
[target.'cfg(target_arch = "wasm32")'.dependencies]
getrandom = { version = "0.2", features = ["js"] }
console_error_panic_hook = "0.1"
wee_alloc = "0.4"
```

## Service Architecture in Rust

### 0. Shared WASM Game Logic (`shared-game-logic/`)

**WASM-Compiled Components:**
```rust
// lib.rs - WASM entry point
use wasm_bindgen::prelude::*;

#[wasm_bindgen]
pub fn generate_units_from_token_secret(token_secret: &str, league_id: u8) -> JsValue {
    let units = combat::generate_units_from_token_secret(token_secret, league_id);
    serde_wasm_bindgen::to_value(&units).unwrap()
}

#[wasm_bindgen]
pub fn process_combat(unit1: JsValue, unit2: JsValue, player1_npub: &str, player2_npub: &str) -> JsValue {
    let unit1: Unit = serde_wasm_bindgen::from_value(unit1).unwrap();
    let unit2: Unit = serde_wasm_bindgen::from_value(unit2).unwrap();
    
    let result = combat::process_combat(unit1, unit2, player1_npub, player2_npub).unwrap();
    serde_wasm_bindgen::to_value(&result).unwrap()
}

// combat.rs - Shared combat logic (identical to game-engine-bot)
pub fn generate_units_from_token_secret(token_secret: &str, league_id: u8) -> [Unit; 8] {
    // Same deterministic unit generation as server
    // Uses SHA256 to create 8 units from token secret
    // Applies league modifiers identically
}

pub fn process_combat(
    unit1: Unit,
    unit2: Unit, 
    player1_npub: &str,
    player2_npub: &str,
) -> Result<RoundResult, GameEngineError> {
    // Identical combat resolution logic
    // Abilities: Boost, Shield, Heal
    // Damage calculation: attack - defense (min 0)
}

// game_state.rs - Shared data structures
#[derive(Debug, Clone, Copy, Serialize, Deserialize)]
#[wasm_bindgen]
pub struct Unit {
    pub attack: u8,
    pub defense: u8,
    pub health: u8,
    pub max_health: u8,
    pub ability: Ability,
}

#[derive(Debug, Clone, Copy, PartialEq, Serialize, Deserialize)]
#[wasm_bindgen]
pub enum Ability {
    None,
    Boost,
    Shield,
    Heal,
}
```

**WASM Build Configuration:**
```toml
# Cargo.toml for shared-game-logic crate
[lib]
crate-type = ["cdylib"]

[dependencies]
wasm-bindgen = { version = "0.2", features = ["serde-serialize"] }
serde = { version = "1.0", features = ["derive"] }
serde-wasm-bindgen = "0.4"
sha2 = "0.10"

# WASM-specific
console_error_panic_hook = "0.1"
wee_alloc = "0.4"

[dependencies.web-sys]
version = "0.3"
features = [
  "console",
]
```

### 1. Game Engine Bot (`game-engine-bot/`)

**Main Components (Using Shared Logic):**
```rust
// Uses shared-game-logic as a regular Rust dependency (not WASM)
use shared_game_logic::{combat, game_state::{Unit, Ability, RoundResult}};

// main.rs - Authoritative game engine
pub struct GameEngineBot {
    config: GameEngineConfig,
    match_manager: Arc<tokio::sync::Mutex<MatchManager>>,
    cashu_client: Arc<CashuClient>,
}

impl GameEngineBot {
    pub async fn resolve_round(&self, match_id: &str, round: u8) -> Result<RoundResult, GameEngineError> {
        let manager = self.match_manager.lock().await;
        let (reveal1, reveal2) = manager.get_round_reveals(match_id, round)?;
        
        // Use shared combat logic (same as WASM)
        let result = combat::process_combat(
            reveal1.unit,
            reveal2.unit,
            &manager.get_match(match_id)?.players[0],
            &manager.get_match(match_id)?.players[1],
        )?;
        
        Ok(result)
    }
}
```

### 2. Tournament System (`tournament-system/`)

**Main Components:**
```rust
// src/swiss.rs
pub fn generate_swiss_pairings(
    players: &[Player], 
    round: u32,
    previous_pairings: &[Pairing]
) -> Vec<Pairing> {
    // Swiss system: pair players with similar records
    // Avoid repeat pairings when possible
}

// src/scoring.rs
pub fn calculate_standings(results: &[MatchResult]) -> Vec<PlayerStanding> {
    // 10 points per match win
    // Betting accuracy bonus: 0.5 * accuracy_percentage  
    // Tiebreakers: opponent win%, total damage dealt
}
```

### 3. API Gateway with Cashu/Nostr Integration (`api-gateway/`)

**Main Components:**
```rust
// src/cashu_service.rs
use cashu::{Mint, Token};

pub struct CashuService {
    mint: Mint,
}

impl CashuService {
    pub async fn mint_mana_token(&self, payment: LightningPayment, league: LeagueId) -> Result<Token, CashuError> {
        // Handle Lightning payment (5% fee)
        // Mint token using Cashu library
        // Token deterministically generates 32-byte unit set
    }
    
    pub async fn create_loot_token(&self, winner_npub: &str, amount: u64) -> Result<LockedToken, CashuError> {
        // Create locked token using Cashu's NUT-11 implementation
    }
}

// src/nostr_service.rs
use nostr_sdk::{Client, Event, EventBuilder};

pub struct NostrService {
    client: Client,
}

impl NostrService {
    pub async fn publish_match_announcement(&self, match_id: &str, players: [&str; 2]) -> Result<(), NostrError> {
        // Publish match creation event
    }
    
    pub async fn handle_commitment(&self, event: Event) -> Result<Commitment, NostrError> {
        // Process unit commitment events
    }
    
    pub async fn handle_reveal(&self, event: Event) -> Result<Reveal, NostrError> {
        // Process unit reveal events
        // Verify commitment matches reveal
    }
}
```

## Required Code References

The main areas where we need specific implementation guidance:

### 1. Cashu Rust Integration
- Which Cashu Rust crate/library to use
- How to integrate Lightning payments with the mint
- Token parsing for unit generation (32-byte → 8 units)

### 2. Swiss Tournament Algorithm
- Rust implementation reference for Swiss pairing
- Handling edge cases (byes, dropouts, tiebreakers)

Everything else (Nostr integration, web APIs, database access, game mechanics) has well-established Rust patterns and libraries.

## Implementation Priority

### Phase 2 Core Development:
1. **Game Engine** - Combat resolution and unit parsing (straightforward)
2. **Cashu Integration** - Need library reference  
3. **Nostr Client** - Use `nostr-sdk` (well documented)
4. **API Gateway** - Standard `axum` patterns
5. **Database** - Standard `sqlx` patterns

### Phase 3 Tournament System:
1. **Swiss Pairing** - Need algorithm reference
2. **Scoring System** - Straightforward implementation
3. **Tournament API** - Standard REST patterns

The Rust ecosystem provides excellent libraries for web services, databases, and cryptography. The main integration points needing specific guidance are:
- Cashu library usage and Lightning integration
- Swiss tournament pairing algorithm implementation